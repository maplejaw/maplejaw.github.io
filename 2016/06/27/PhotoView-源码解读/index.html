<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>PhotoView 源码解读 | maplejaw的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="开源库地址：https://github.com/chrisbanes/PhotoViewPhotoView是一个用来帮助开发者轻松实现ImageView缩放的库。开发者可以轻易控制对图片的缩放旋等等操作。PhotoView的使用极其简单，而且提供了两种方案。可以使用普通的ImageView，也可以使用该库中提供的ImageView（PhotoView）。">
<meta property="og:type" content="article">
<meta property="og:title" content="PhotoView 源码解读">
<meta property="og:url" content="http://www.maplejaw.com/2016/06/27/PhotoView-源码解读/index.html">
<meta property="og:site_name" content="maplejaw的技术博客">
<meta property="og:description" content="开源库地址：https://github.com/chrisbanes/PhotoViewPhotoView是一个用来帮助开发者轻松实现ImageView缩放的库。开发者可以轻易控制对图片的缩放旋等等操作。PhotoView的使用极其简单，而且提供了两种方案。可以使用普通的ImageView，也可以使用该库中提供的ImageView（PhotoView）。">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/hi1r0j8hcwjurkvobsoq4xvi/image_1akkgdkg01saq1l01jdvaaqeeh9.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/z55a1fj5ejh5m70b2sa7c6o3/image_1am7q83srm9n1nb5odsarv17sm9.png">
<meta property="og:updated_time" content="2016-06-27T15:48:16.741Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PhotoView 源码解读">
<meta name="twitter:description" content="开源库地址：https://github.com/chrisbanes/PhotoViewPhotoView是一个用来帮助开发者轻松实现ImageView缩放的库。开发者可以轻易控制对图片的缩放旋等等操作。PhotoView的使用极其简单，而且提供了两种方案。可以使用普通的ImageView，也可以使用该库中提供的ImageView（PhotoView）。">
<meta name="twitter:image" content="http://static.zybuluo.com/maplejaw/hi1r0j8hcwjurkvobsoq4xvi/image_1akkgdkg01saq1l01jdvaaqeeh9.png">
  
    <link rel="alternative" href="/atom.xml" title="maplejaw的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/uploads/avatar.jpeg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">maplejaw</a></h1>
		</hgroup>

		
		<p class="header-subtitle">不忘初心，方得始终</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">归档</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/maplejaw" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/RxJava/" style="font-size: 12px;">RxJava</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/python/" style="font-size: 14px;">python</a> <a href="/tags/开源库/" style="font-size: 10px;">开源库</a> <a href="/tags/插件化探索/" style="font-size: 16px;">插件化探索</a> <a href="/tags/源码解读/" style="font-size: 18px;">源码解读</a> <a href="/tags/知识整理/" style="font-size: 12px;">知识整理</a> <a href="/tags/自定义View/" style="font-size: 10px;">自定义View</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">maplejaw</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img src="/uploads/avatar.jpeg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
			</div>
			<hgroup>
			  <h1 class="header-author">maplejaw</h1>
			</hgroup>
			
			<p class="header-subtitle">不忘初心，方得始终</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">归档</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/maplejaw" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-PhotoView-源码解读" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/27/PhotoView-源码解读/" class="article-date">
  	<time datetime="2016-06-27T15:35:29.000Z" itemprop="datePublished">2016-06-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      PhotoView 源码解读
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码解读/">源码解读</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>开源库地址：<a href="https://github.com/chrisbanes/PhotoView" target="_blank" rel="external">https://github.com/chrisbanes/PhotoView</a><br>PhotoView是一个用来帮助开发者轻松实现ImageView缩放的库。开发者可以轻易控制对图片的缩放旋等等操作。<br><img src="http://static.zybuluo.com/maplejaw/hi1r0j8hcwjurkvobsoq4xvi/image_1akkgdkg01saq1l01jdvaaqeeh9.png" alt="image_1akkgdkg01saq1l01jdvaaqeeh9.png-11.6kB"><br>PhotoView的使用极其简单，而且提供了两种方案。可以使用普通的ImageView，也可以使用该库中提供的ImageView（PhotoView）。</p>
<a id="more"></a>
<ul>
<li><p>使用PhotoView<br>只需如下引用该库中的ImageView，无需关心其它实现细节，你的ImageView便可拥有缩放效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;uk.co.senab.photoview.PhotoView</span><br><span class="line">            android:id=<span class="string">"@+id/iv_photo"</span></span><br><span class="line">            android:layout_width=<span class="string">"fill_parent"</span></span><br><span class="line">            android:layout_height=<span class="string">"fill_parent"</span> /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>针对普通ImageView<br>有的时候，可能因为一些历史原因，使得你不得不用原来的ImageView。幸运的是该库也提供了一种解决方案。只需用PhotoViewAttacher包装即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PhotoViewAttacher mAttacher=<span class="keyword">new</span> PhotoViewAttacher(mImageView);<span class="comment">//用PhotoViewAttacher包装</span></span><br><span class="line"></span><br><span class="line">mAttacher.update();<span class="comment">//当图片改变时需调用update();</span></span><br><span class="line"></span><br><span class="line">mAttacher.cleanup();<span class="comment">//当ImageView不再使用时回收资源（可在onDestory中 调用）。PhotoView已经实现了这个功能不需要自己管理。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>PhotoView真的很神奇，接下来我们去源码里一探究竟吧。顺便多说一句，图片的缩放大量运用到了Matrix相关知识，不了解的务必要先查阅相关资料哦。强烈推荐<a href="http://www.cnblogs.com/qiengo/archive/2012/06/30/2570874.html" target="_blank" rel="external">Android Matrix</a> 这篇文章，当然也可以看我的这篇<a href="http://blog.csdn.net/maplejaw_/article/details/51728818" target="_blank" rel="external">Android Matrix矩阵详解</a>。</p>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>这次源码解读我们从使用普通ImageView入手，普通的ImageView如果想缩放，必须依赖于PhotoViewAttacher，而PhotoViewAttacher又实现了IPhotoView接口。IPhotoView主要定义了一些常用的操作和默认值，由于方法实在太多了，就不一一列举了，直接上图。<br>IPhotoView定义的所有抽象方法如下。<br><img src="http://static.zybuluo.com/maplejaw/z55a1fj5ejh5m70b2sa7c6o3/image_1am7q83srm9n1nb5odsarv17sm9.png" alt="image_1am7q83srm9n1nb5odsarv17sm9.png-98.5kB"><br>IPhotoView的部分源码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPhotoView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> DEFAULT_MAX_SCALE = <span class="number">3.0f</span>;<span class="comment">//默认最大缩放倍数为3倍</span></span><br><span class="line">    <span class="keyword">float</span> DEFAULT_MID_SCALE = <span class="number">1.75f</span>;<span class="comment">//默认中间缩放倍数为1.75倍</span></span><br><span class="line">    <span class="keyword">float</span> DEFAULT_MIN_SCALE = <span class="number">1.0f</span>;<span class="comment">//默认最小缩放倍数为1倍</span></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_ZOOM_DURATION = <span class="number">200</span>;<span class="comment">//默认的缩放间隔为200ms</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canZoom</span><span class="params">()</span></span>;<span class="comment">//可以缩放</span></span><br><span class="line">    <span class="function">RectF <span class="title">getDisplayRect</span><span class="params">()</span></span>;<span class="comment">//获取显示矩形</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">setDisplayMatrix</span><span class="params">(Matrix finalMatrix)</span></span>;<span class="comment">//设置显示矩阵</span></span><br><span class="line">    <span class="function">Matrix <span class="title">getDisplayMatrix</span><span class="params">()</span></span>;<span class="comment">//获取显示矩阵</span></span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    <span class="comment">//省略了部分源码</span></span><br></pre></td></tr></table></figure></p>
<p>介绍完IPhotoView接口后，现在改来看看PhotoViewAttacher了，PhotoViewAttacher的属性也比较多，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Interpolator mInterpolator = <span class="keyword">new</span> AccelerateDecelerateInterpolator();<span class="comment">//插值器，用于缩放动画</span></span><br><span class="line"><span class="keyword">int</span> ZOOM_DURATION = DEFAULT_ZOOM_DURATION;<span class="comment">//默认的缩放间隔</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_NONE = -<span class="number">1</span>;<span class="comment">//图片两边都不在边缘内</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_LEFT = <span class="number">0</span>;<span class="comment">//图片左边显示在View的左边缘内</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_RIGHT = <span class="number">1</span>;<span class="comment">//图片右边显示在View的右边缘内</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_BOTH = <span class="number">2</span>;<span class="comment">//图片两边都在边缘内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> SINGLE_TOUCH = <span class="number">1</span>;<span class="comment">//单指</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> mMinScale = DEFAULT_MIN_SCALE;<span class="comment">//最小缩放倍数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> mMidScale = DEFAULT_MID_SCALE;<span class="comment">//中间缩放倍数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> mMaxScale = DEFAULT_MAX_SCALE;<span class="comment">//最大缩放倍数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mAllowParentInterceptOnEdge = <span class="keyword">true</span>;<span class="comment">//当在边缘操作时，允许父布局拦截事件。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mBlockParentIntercept = <span class="keyword">false</span>;<span class="comment">//阻止父布局拦截事件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> WeakReference&lt;ImageView&gt; mImageView;<span class="comment">//弱引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手势探测器</span></span><br><span class="line"><span class="keyword">private</span> GestureDetector mGestureDetector;<span class="comment">//单击，长按，Fling</span></span><br><span class="line"><span class="keyword">private</span> uk.co.senab.photoview.gestures.GestureDetector mScaleDragDetector;<span class="comment">//缩放和拖拽</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Matrix mBaseMatrix = <span class="keyword">new</span> Matrix();<span class="comment">//基础矩阵,用来保存初始的显示矩阵</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Matrix mDrawMatrix = <span class="keyword">new</span> Matrix();<span class="comment">//绘画矩阵，用来计算最后显示区域的矩阵，是在mBaseMatrix和mSuppMatrix的基础上计算出来的。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Matrix mSuppMatrix = <span class="keyword">new</span> Matrix();<span class="comment">//这个矩阵我也不知道怎么称呼，也不知道是不是Supply的意思，暂且叫作供应矩阵吧，用来保存旋转平移和缩放的矩阵。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RectF mDisplayRect = <span class="keyword">new</span> RectF();<span class="comment">//显示矩形</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span>[] mMatrixValues = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">9</span>];<span class="comment">//用来保存矩阵的值。3*3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 各类监听</span></span><br><span class="line"><span class="keyword">private</span> OnMatrixChangedListener mMatrixChangeListener;</span><br><span class="line"><span class="keyword">private</span> OnPhotoTapListener mPhotoTapListener;</span><br><span class="line"><span class="keyword">private</span> OnViewTapListener mViewTapListener;</span><br><span class="line"><span class="keyword">private</span> OnLongClickListener mLongClickListener;</span><br><span class="line"><span class="keyword">private</span> OnScaleChangeListener mScaleChangeListener;</span><br><span class="line"><span class="keyword">private</span> OnSingleFlingListener mSingleFlingListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存ImageView的top,right,bottom,left</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mIvTop, mIvRight, mIvBottom, mIvLeft;</span><br><span class="line"><span class="comment">//Fling时的Runable</span></span><br><span class="line"><span class="keyword">private</span> FlingRunnable mCurrentFlingRunnable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mScrollEdge = EDGE_BOTH;<span class="comment">//两边边缘</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> mBaseRotation;<span class="comment">//基础旋转角度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mZoomEnabled;<span class="comment">//是否可以缩放</span></span><br><span class="line"><span class="keyword">private</span> ScaleType mScaleType = ScaleType.FIT_CENTER;<span class="comment">//默认缩放类型</span></span><br></pre></td></tr></table></figure></p>
<p>此外PhotoViewAttacher中还定义了以下几个接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnMatrixChangedListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 当用来显示Drawable的Matrix改变时回调</span><br><span class="line">     * <span class="doctag">@param</span> rect - 显示Drawable的新边界</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMatrixChanged</span><span class="params">(RectF rect)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnScaleChangeListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 当ImageView改变缩放时回调</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> scaleFactor 小于1表示缩小,大于1表示放大</span><br><span class="line">     * <span class="doctag">@param</span> focusX     缩放焦点X</span><br><span class="line">     * <span class="doctag">@param</span> focusY     缩放焦点Y</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onScaleChange</span><span class="params">(<span class="keyword">float</span> scaleFactor, <span class="keyword">float</span> focusX, <span class="keyword">float</span> focusY)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnPhotoTapListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * </span><br><span class="line">     *当用户敲击在照片上时回调，如果在空白区域不会回调</span><br><span class="line">     * <span class="doctag">@param</span> view - ImageView</span><br><span class="line">     * <span class="doctag">@param</span> x    -用户敲击的位置（在图片中从左往右的位置）占图片宽度的百分比</span><br><span class="line">     * <span class="doctag">@param</span> y    -用户敲击的位置（在图片中从上往下的位置）占图片高度的百分比</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onPhotoTap</span><span class="params">(View view, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 在图片外部的空白区域敲击回调</span><br><span class="line">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onOutsidePhotoTap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnViewTapListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 只要用户敲击ImageView就会回调，不管是不是在图片上。</span><br><span class="line">     * <span class="doctag">@param</span> view - View the user tapped.</span><br><span class="line">     * <span class="doctag">@param</span> x    -敲击View的x坐标</span><br><span class="line">     * <span class="doctag">@param</span> y    -敲击View的y坐标</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onViewTap</span><span class="params">(View view, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSingleFlingListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 用户使用单指在ImageView上快速滑动时回调，不管是不是在图片上。</span><br><span class="line">     * <span class="doctag">@param</span> e1        - 第一次触摸事件</span><br><span class="line">     * <span class="doctag">@param</span> e2        - 第二次触摸事件</span><br><span class="line">     * <span class="doctag">@param</span> velocityX - 水平滑过的速度.</span><br><span class="line">     * <span class="doctag">@param</span> velocityY - 竖直滑过的素组.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在看完PhotoViewAttacher的一些属性和接口外，现在就来看PhotoViewAttacher的构造方法。即<code>new PhotoViewAttacher(mImageView)</code>这一句。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PhotoViewAttacher</span><span class="params">(ImageView imageView)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(imageView, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PhotoViewAttacher</span><span class="params">(ImageView imageView, <span class="keyword">boolean</span> zoomable)</span> </span>&#123;</span><br><span class="line">      mImageView = <span class="keyword">new</span> WeakReference&lt;&gt;(imageView);<span class="comment">//弱引用</span></span><br><span class="line"></span><br><span class="line">      imageView.setDrawingCacheEnabled(<span class="keyword">true</span>);<span class="comment">//开启绘制缓存区，用于获取可见区的bitmap</span></span><br><span class="line">      imageView.setOnTouchListener(<span class="keyword">this</span>);<span class="comment">//设置Touch监听，用于添加手势监听</span></span><br><span class="line"></span><br><span class="line">      ViewTreeObserver observer = imageView.getViewTreeObserver();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> != observer)</span><br><span class="line">          observer.addOnGlobalLayoutListener(<span class="keyword">this</span>);<span class="comment">//用于监听ImageView的大小</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 确保ImageView的ScaleType为Matrix</span></span><br><span class="line">      setImageViewScaleTypeMatrix(imageView);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (imageView.isInEditMode()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//初始化多指缩放/拖拽手势探测器</span></span><br><span class="line">      mScaleDragDetector = VersionedGestureDetector.newInstance(</span><br><span class="line">              imageView.getContext(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//初始化其它手势监听（长按,Fling）</span></span><br><span class="line">      mGestureDetector = <span class="keyword">new</span> GestureDetector(imageView.getContext(),</span><br><span class="line">              <span class="keyword">new</span> GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//长按</span></span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">                      <span class="keyword">if</span> (<span class="keyword">null</span> != mLongClickListener) &#123;</span><br><span class="line">                          mLongClickListener.onLongClick(getImageView());</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  </span><br><span class="line">                  <span class="comment">//Fling</span></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2,</span><br><span class="line">                                         <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</span><br><span class="line">                      <span class="keyword">if</span> (mSingleFlingListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          <span class="keyword">if</span> (getScale() &gt; DEFAULT_MIN_SCALE) &#123;</span><br><span class="line">                              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          <span class="keyword">if</span> (MotionEventCompat.getPointerCount(e1) &gt; SINGLE_TOUCH</span><br><span class="line">                                  || MotionEventCompat.getPointerCount(e2) &gt; SINGLE_TOUCH) &#123;</span><br><span class="line">                              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                          </span><br><span class="line">                          <span class="keyword">return</span> mSingleFlingListener.onFling(e1, e2, velocityX, velocityY);</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//设置默认的双击处理方案。</span></span><br><span class="line">      mGestureDetector.setOnDoubleTapListener(<span class="keyword">new</span> DefaultOnDoubleTapListener(<span class="keyword">this</span>));</span><br><span class="line">      <span class="comment">//基础旋转角度</span></span><br><span class="line">      mBaseRotation = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//设置是否可缩放</span></span><br><span class="line">      setZoomable(zoomable);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>构造方法主要做了一些初始化工作，比如添加了手势监听(双指缩放，拖拽，双击，长按)等等。而且，如果希望图片具备缩放功能，还得设置ImageView的scaleType为matrix，下面我们就一步步剖析。</p>
<h3 id="默认设置"><a href="#默认设置" class="headerlink" title="默认设置"></a>默认设置</h3><p>为了理解起来更连贯一点，我们先看<code>setZoomable</code>中的源码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZoomable</span><span class="params">(<span class="keyword">boolean</span> zoomable)</span> </span>&#123;</span><br><span class="line">     mZoomEnabled = zoomable;</span><br><span class="line">     update();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     ImageView imageView = getImageView();<span class="comment">//获取ImageView</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">null</span> != imageView) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mZoomEnabled) &#123;</span><br><span class="line">            <span class="comment">//再次确保ImageView的ScaleType为MATRIX</span></span><br><span class="line">             setImageViewScaleTypeMatrix(imageView);</span><br><span class="line"></span><br><span class="line">             <span class="comment">//更新基础矩阵mBaseMatrix</span></span><br><span class="line">             updateBaseMatrix(imageView.getDrawable());</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//重置矩阵</span></span><br><span class="line">             resetMatrix();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，除了赋值mZoomEnabled外，还调用了<code>update()</code>方法，前面我们说了，每次更换图片时需调用<code>update()</code>刷新。在<code>update()</code>中，如果是可缩放的，就更新<code>mBaseMatrix</code>,否则重置矩阵。<br><code>updateBaseMatrix</code>的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateBaseMatrix</span><span class="params">(Drawable d)</span> </span>&#123;</span><br><span class="line">    ImageView imageView = getImageView();<span class="comment">//获取ImageView</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == imageView || <span class="keyword">null</span> == d) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取ImageView的宽高</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> viewWidth = getImageViewWidth(imageView);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> viewHeight = getImageViewHeight(imageView);</span><br><span class="line">    <span class="comment">//获取Drawable的固有的宽高</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> drawableWidth = d.getIntrinsicWidth();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> drawableHeight = d.getIntrinsicHeight();</span><br><span class="line"></span><br><span class="line">    mBaseMatrix.reset();<span class="comment">//重置mBaseMatrix矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取宽的缩放比，drawableWidth * widthScale = viewWidth</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> widthScale = viewWidth / drawableWidth;</span><br><span class="line">    <span class="comment">//获取高的缩放比，drawableHeight * heightScale = viewHeight</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> heightScale = viewHeight / drawableHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意，这里的ScaleType不是ImageView的ScaleType，因为ImageView的ScaleType已被强制设为Matrix。这里的ScaleType是PhotoViewAttacher的ScaleType，因此可以通过设置PhotoViewAttacher的setScaleType来模拟原ImageView的效果，以满足实际需求。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mScaleType == ScaleType.CENTER) &#123;<span class="comment">//如果缩放类型为ScaleType.CENTER</span></span><br><span class="line">        <span class="comment">//基础矩阵就平移两者的宽度差一半，以保持居中</span></span><br><span class="line">        mBaseMatrix.postTranslate((viewWidth - drawableWidth) / <span class="number">2F</span>,</span><br><span class="line">                (viewHeight - drawableHeight) / <span class="number">2F</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mScaleType == ScaleType.CENTER_CROP) &#123;<span class="comment">//如果缩放类型为ScaleType.CENTER_CROP</span></span><br><span class="line">        <span class="keyword">float</span> scale = Math.max(widthScale, heightScale);<span class="comment">//取最大值</span></span><br><span class="line">        mBaseMatrix.postScale(scale, scale);<span class="comment">//使最小的那一边也缩放到View的尺寸</span></span><br><span class="line">        <span class="comment">//平移到中间</span></span><br><span class="line">        mBaseMatrix.postTranslate((viewWidth - drawableWidth * scale) / <span class="number">2F</span>,</span><br><span class="line">                (viewHeight - drawableHeight * scale) / <span class="number">2F</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mScaleType == ScaleType.CENTER_INSIDE) &#123;</span><br><span class="line">        <span class="comment">//如果缩放类型为ScaleType.CENTER_INSIDE</span></span><br><span class="line">        <span class="comment">//计算缩放值</span></span><br><span class="line">        <span class="keyword">float</span> scale = Math.min(<span class="number">1.0f</span>, Math.min(widthScale, heightScale));</span><br><span class="line">        <span class="comment">//当图片宽高超出View宽高时调用,否则缩放还是1</span></span><br><span class="line">        mBaseMatrix.postScale(scale, scale);</span><br><span class="line">        <span class="comment">//平移到中间</span></span><br><span class="line">        mBaseMatrix.postTranslate((viewWidth - drawableWidth * scale) / <span class="number">2F</span>,</span><br><span class="line">                (viewHeight - drawableHeight * scale) / <span class="number">2F</span>);<span class="comment">//平移</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果是FIT_XX相关的缩放类型</span></span><br><span class="line">        RectF mTempSrc = <span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, drawableWidth, drawableHeight);</span><br><span class="line">        RectF mTempDst = <span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, viewWidth, viewHeight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>) mBaseRotation % <span class="number">180</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            mTempSrc = <span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, drawableHeight, drawableWidth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接根据Matrix提供的setRectToRect来设置</span></span><br><span class="line">        <span class="keyword">switch</span> (mScaleType) &#123;</span><br><span class="line">            <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">                mBaseMatrix</span><br><span class="line">                        .setRectToRect(mTempSrc, mTempDst, ScaleToFit.CENTER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> FIT_START:</span><br><span class="line">                mBaseMatrix.setRectToRect(mTempSrc, mTempDst, ScaleToFit.START);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> FIT_END:</span><br><span class="line">                mBaseMatrix.setRectToRect(mTempSrc, mTempDst, ScaleToFit.END);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> FIT_XY:</span><br><span class="line">                mBaseMatrix.setRectToRect(mTempSrc, mTempDst, ScaleToFit.FILL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重置矩阵</span></span><br><span class="line">    resetMatrix();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出<code>updateBaseMatrix</code>,主要是在根据ScaleType来调整显示位置和缩放级别，使其达到ImageView的ScaleType效果。为什么需要这个功能？由于ImageView已被强制设置ScaleType为Matrix，但是如果我们仍然需要ScaleType的显示效果怎么办？于是PhotoViewAttacher提供了setScaleType来模拟相关效果。从上面的源码应该不难看出，<code>mBaseMatrix</code>用来保存根据ScaleType调整过的的原始矩阵。默认的ScaleType为ScaleType.FIT_CENTER。<br>接下来，我们来看<code>resetMatrix()</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mSuppMatrix.reset();<span class="comment">//重置供应矩阵</span></span><br><span class="line">        setRotationBy(mBaseRotation);<span class="comment">//设置初始的旋转角度</span></span><br><span class="line">        setImageViewMatrix(getDrawMatrix());<span class="comment">//把最mDrawMatrix设置给ImageView，以对图片进行变化。</span></span><br><span class="line">        checkMatrixBounds();<span class="comment">//检查Matrix边界</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>设置旋转角度的源码如下，mSuppMatrix后乘了旋转角度。然后进行检查边界，最后进行显示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRotationBy</span><span class="params">(<span class="keyword">float</span> degrees)</span> </span>&#123;</span><br><span class="line">        mSuppMatrix.postRotate(degrees % <span class="number">360</span>);<span class="comment">//后乘旋转角度</span></span><br><span class="line">        checkAndDisplayMatrix();<span class="comment">//检查Matrix边界，然后显示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查Matrix边界和显示</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkAndDisplayMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkMatrixBounds()) &#123;</span><br><span class="line">           <span class="comment">//调整效果进行显示</span></span><br><span class="line">            setImageViewMatrix(getDrawMatrix());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>checkMatrixBounds()</code>用来检查Matrix边界。相关源码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkMatrixBounds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ImageView imageView = getImageView();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == imageView) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取最终的显示区域矩形</span></span><br><span class="line">    <span class="keyword">final</span> RectF rect = getDisplayRect(getDrawMatrix());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == rect) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取显示矩形的宽高</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> height = rect.height(), width = rect.width();</span><br><span class="line">    <span class="keyword">float</span> deltaX = <span class="number">0</span>, deltaY = <span class="number">0</span>;<span class="comment">//计算调整边界时要平移的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下根据缩放类型来调整显示区域</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewHeight = getImageViewHeight(imageView);<span class="comment">//获取View的高</span></span><br><span class="line">    <span class="keyword">if</span> (height &lt;= viewHeight) &#123;<span class="comment">//如果图片的高小于等于View，说明图片的垂直方向可以完全显示在View里面</span></span><br><span class="line">        <span class="comment">//于是根据缩放类型进行边界调整</span></span><br><span class="line">        <span class="keyword">switch</span> (mScaleType) &#123;</span><br><span class="line">            <span class="keyword">case</span> FIT_START:</span><br><span class="line">                deltaY = -rect.top;<span class="comment">//向上移动到View的顶部</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FIT_END:</span><br><span class="line">                deltaY = viewHeight - height - rect.top;<span class="comment">//向下移动到View的底部</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                deltaY = (viewHeight - height) / <span class="number">2</span> - rect.top;<span class="comment">//否则就居中显示</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rect.top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果图片高度超出来View的高，但是rect.top &gt; 0说明ImageView上边还有空余的区域。</span></span><br><span class="line">        deltaY = -rect.top;<span class="comment">//于是计算偏移距离</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rect.bottom &lt; viewHeight) &#123;</span><br><span class="line">       <span class="comment">//同理。底部也有空余</span></span><br><span class="line">        deltaY = viewHeight - rect.bottom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//获取ImageView的宽，同理进行边界调整。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewWidth = getImageViewWidth(imageView);</span><br><span class="line">    <span class="keyword">if</span> (width &lt;= viewWidth) &#123;<span class="comment">//如果宽度小于View的宽，进行相应调整</span></span><br><span class="line">        <span class="keyword">switch</span> (mScaleType) &#123;</span><br><span class="line">            <span class="keyword">case</span> FIT_START:</span><br><span class="line">                deltaX = -rect.left;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FIT_END:</span><br><span class="line">                deltaX = viewWidth - width - rect.left;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                deltaX = (viewWidth - width) / <span class="number">2</span> - rect.left;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mScrollEdge = EDGE_BOTH;<span class="comment">//图片宽度小于View的宽度，说明两边显示在边缘内</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rect.left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mScrollEdge = EDGE_LEFT;<span class="comment">//rect.left &gt; 0表示显示在左边边缘内</span></span><br><span class="line">        deltaX = -rect.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rect.right &lt; viewWidth) &#123;</span><br><span class="line">        deltaX = viewWidth - rect.right;</span><br><span class="line">        mScrollEdge = EDGE_RIGHT;<span class="comment">//右边在边缘内</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mScrollEdge = EDGE_NONE;<span class="comment">//两边都不在边缘内</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后，将平移给mSuppMatrix</span></span><br><span class="line">    mSuppMatrix.postTranslate(deltaX, deltaY);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么要检查边界呢？那是因为当你进行旋转或缩放变换后，由于缩放的锚点是以手指为中心的，有时候会发现显示的区域不对，比如说，当图片大于View的宽高时，但是矩阵的边界与View之间居然还有空白区，显然不太合理。这时需要进行平移对齐View的宽高。</p>
<p>在检查显示边界时，我们需要获取图片的显示矩形，那么怎么获取Drawable的最终显示矩形呢？<br><code>getDrawMatrix()</code>用来获取mDrawMatrix最终矩阵,mDrawMatrix其实是在mBaseMatrix基础矩阵上后乘mSuppMatrix供应矩阵产生的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Matrix <span class="title">getDrawMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDrawMatrix.set(mBaseMatrix);</span><br><span class="line">    mDrawMatrix.postConcat(mSuppMatrix);</span><br><span class="line">    <span class="keyword">return</span> mDrawMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>setImageViewMatrix</code>将最终的矩阵应用到ImageView中，这时我们就能看到显示效果了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setImageViewMatrix</span><span class="params">(Matrix matrix)</span> </span>&#123;</span><br><span class="line">    ImageView imageView = getImageView();<span class="comment">//获取ImageView</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != imageView) &#123;</span><br><span class="line"></span><br><span class="line">        checkImageViewScaleType();<span class="comment">//检查缩放类型，必须为Matrix，否则抛异常</span></span><br><span class="line">        imageView.setImageMatrix(matrix);<span class="comment">//应用矩阵 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//回调监听</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != mMatrixChangeListener) &#123;</span><br><span class="line">            RectF displayRect = getDisplayRect(matrix);<span class="comment">//获取显示矩形</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != displayRect) &#123;</span><br><span class="line">                mMatrixChangeListener.onMatrixChanged(displayRect);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，通过如下的源码可以获取显示矩形,<code>matrix.mapRect</code>用来映射最新的变换到原始的矩形。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RectF <span class="title">getDisplayRect</span><span class="params">(Matrix matrix)</span> </span>&#123;</span><br><span class="line">    ImageView imageView = getImageView();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != imageView) &#123;</span><br><span class="line">        Drawable d = imageView.getDrawable();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != d) &#123;</span><br><span class="line">            mDisplayRect.set(<span class="number">0</span>, <span class="number">0</span>, d.getIntrinsicWidth(),</span><br><span class="line">                    d.getIntrinsicHeight());<span class="comment">//获取Drawable尺寸，初始化原始矩形</span></span><br><span class="line">            matrix.mapRect(mDisplayRect);<span class="comment">//将矩阵的变换映射给mDisplayRect，得到最终矩形</span></span><br><span class="line">            <span class="keyword">return</span> mDisplayRect;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看完以上的源码，相信流程已经非常清楚了，当设置图片时，通过<code>update()</code>我们可以初始化一个mBaseMatrix,然后如果想缩放、旋转等,进行设置应用到mSuppMatrix,最终通过对mBaseMatrix和mSuppMatrix计算得到mDrawMatrix，然后应用到ImageView中，便完成了我们的使命了。</p>
<p>既然一切的变换都会应用到mSuppMatrix中。那么接下来我们回到<code>PhotoViewAttacher</code>的构造方法中继续阅读其他源码，以了解这个过程到底是怎么实现的。</p>
<h3 id="Touch事件监听"><a href="#Touch事件监听" class="headerlink" title="Touch事件监听"></a>Touch事件监听</h3><p>Touch事件中，主要让手势探测器进行处理事件。核心源码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以缩放且有图片时才能处理手势监听</span></span><br><span class="line">    <span class="keyword">if</span> (mZoomEnabled &amp;&amp; hasDrawable((ImageView) v)) &#123;</span><br><span class="line">        ViewParent parent = v.getParent();</span><br><span class="line">        <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ACTION_DOWN:</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != parent) &#123;</span><br><span class="line">                   <span class="comment">//不允许父布局拦截ACTION_DOWN事件</span></span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    LogManager.getLogger().i(LOG_TAG, <span class="string">"onTouch getParent() returned null"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">               </span><br><span class="line">                cancelFling(); <span class="comment">//取消Fling事件</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ACTION_CANCEL:</span><br><span class="line">            <span class="keyword">case</span> ACTION_UP:</span><br><span class="line">                <span class="comment">//当手指抬起时</span></span><br><span class="line">                <span class="keyword">if</span> (getScale() &lt; mMinScale) &#123;<span class="comment">//如果小于最小值</span></span><br><span class="line">                    RectF rect = getDisplayRect();<span class="comment">//获取显示矩阵</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != rect) &#123;</span><br><span class="line">                        <span class="comment">//恢复到最小</span></span><br><span class="line">                        v.post(<span class="keyword">new</span> AnimatedZoomRunnable(getScale(), mMinScale,</span><br><span class="line">                                rect.centerX(), rect.centerY()));</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//如果mScaleDragDetector（缩放、拖拽）不为空，让它处理事件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != mScaleDragDetector) &#123;</span><br><span class="line">            <span class="comment">//获取状态</span></span><br><span class="line">            <span class="keyword">boolean</span> wasScaling = mScaleDragDetector.isScaling();</span><br><span class="line">            <span class="keyword">boolean</span> wasDragging = mScaleDragDetector.isDragging();</span><br><span class="line"></span><br><span class="line">            handled = mScaleDragDetector.onTouchEvent(ev);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//mScaleDragDetector处理事件过后的状态，如果前后都不在缩放和拖拽，就允许父布局拦截</span></span><br><span class="line">            <span class="keyword">boolean</span> didntScale = !wasScaling &amp;&amp; !mScaleDragDetector.isScaling();</span><br><span class="line">            <span class="keyword">boolean</span> didntDrag = !wasDragging &amp;&amp; !mScaleDragDetector.isDragging();</span><br><span class="line"></span><br><span class="line">            mBlockParentIntercept = didntScale &amp;&amp; didntDrag;<span class="comment">//阻止父类拦截的标识</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果mGestureDetector（双击，长按）不为空，交给它处理事件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != mGestureDetector &amp;&amp; mGestureDetector.onTouchEvent(ev)) &#123;</span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="双击缩放"><a href="#双击缩放" class="headerlink" title="双击缩放"></a>双击缩放</h3><p>我们来看一下双击缩放<code>mGestureDetector.setOnDoubleTapListener(new DefaultOnDoubleTapListener(this));</code>这种实现方案。<code>DefaultOnDoubleTapListener</code>实现了<code>GestureDetector.OnDoubleTapListener</code>接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnDoubleTapListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 当单击时回调，不同于OnGestureListener.onSingleTapUp(MotionEvent),这个回调方法只在确信用户不会发生第二次敲击时调用</span><br><span class="line">     * <span class="doctag">@param</span> e  MotionEvent.ACTION_DOWN</span><br><span class="line">     * <span class="doctag">@return</span> true if the event is consumed, else false</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">onSingleTapConfirmed</span><span class="params">(MotionEvent e)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 当双击时调用.</span><br><span class="line">     * <span class="doctag">@param</span> e  MotionEvent.ACTION_DOWN</span><br><span class="line">     * <span class="doctag">@return</span> true if the event is consumed, else false</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">onDoubleTap</span><span class="params">(MotionEvent e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *当两次敲击间回调,回调 MotionEvent.ACTION_DOWN， MotionEvent.ACTION_MOVE， MotionEvent.ACTION_UP事件</span><br><span class="line">     * <span class="doctag">@param</span> e The motion event that occurred during the double-tap gesture.</span><br><span class="line">     * <span class="doctag">@return</span> true if the event is consumed, else false</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">onDoubleTapEvent</span><span class="params">(MotionEvent e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既然知道<code>DefaultOnDoubleTapListener</code>实现了<code>GestureDetector.OnDoubleTapListener</code>接口，那么直接去看<code>DefaultOnDoubleTapListener</code>中是怎么实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单击事件</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapConfirmed</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.photoViewAttacher == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ImageView imageView = photoViewAttacher.getImageView();<span class="comment">//获取ImageView</span></span><br><span class="line">    <span class="comment">//如果OnPhotoTapListener不为null时回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != photoViewAttacher.getOnPhotoTapListener()) &#123;</span><br><span class="line">        <span class="keyword">final</span> RectF displayRect = photoViewAttacher.getDisplayRect();<span class="comment">//获取当前的显示矩形</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != displayRect) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = e.getX(), y = e.getY();<span class="comment">//获取第一次敲击时的坐标</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (displayRect.contains(x, y)) &#123;<span class="comment">//判断是不是敲击在显示矩阵内</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">//如果是的，就计算敲击百分比</span></span><br><span class="line">                <span class="keyword">float</span> xResult = (x - displayRect.left)</span><br><span class="line">                        / displayRect.width();</span><br><span class="line">                <span class="keyword">float</span> yResult = (y - displayRect.top)</span><br><span class="line">                        / displayRect.height();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//敲击图片内回调</span></span><br><span class="line">                photoViewAttacher.getOnPhotoTapListener().onPhotoTap(imageView, xResult, yResult);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果敲击在图片外回调</span></span><br><span class="line">                photoViewAttacher.getOnPhotoTapListener().onOutsidePhotoTap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果OnViewTapListener不为null时回调，不管在不在图片里外</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != photoViewAttacher.getOnViewTapListener()) &#123;</span><br><span class="line">        photoViewAttacher.getOnViewTapListener().onViewTap(imageView, e.getX(), e.getY());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//双击事件，在这里实现缩放</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDoubleTap</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (photoViewAttacher == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">float</span> scale = photoViewAttacher.getScale();<span class="comment">//获取当前缩放比</span></span><br><span class="line">        <span class="keyword">float</span> x = ev.getX();<span class="comment">//获取敲击的坐标</span></span><br><span class="line">        <span class="keyword">float</span> y = ev.getY();<span class="comment">//获取敲击的坐标</span></span><br><span class="line"></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> (scale &lt; photoViewAttacher.getMediumScale()) &#123;</span><br><span class="line">           <span class="comment">//如果之前的缩放小于中等值，现在就缩放到中等值，缩放锚点就是当前的敲击事件坐标，true表示需要动画缩放。</span></span><br><span class="line">            photoViewAttacher.setScale(photoViewAttacher.getMediumScale(), x, y, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scale &gt;= photoViewAttacher.getMediumScale() &amp;&amp; scale &lt; photoViewAttacher.getMaximumScale()) &#123;</span><br><span class="line">            <span class="comment">//如果之前的缩放大于中等值，现在就缩放到最大值，缩放锚点就是当前的敲击事件坐标</span></span><br><span class="line">            photoViewAttacher.setScale(photoViewAttacher.getMaximumScale(), x, y, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则缩放到最小值，缩放锚点就是当前的敲击事件坐标</span></span><br><span class="line">            photoViewAttacher.setScale(photoViewAttacher.getMinimumScale(), x, y, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        <span class="comment">// Can sometimes happen when getX() and getY() is called</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDoubleTapEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由于不需要处理两次敲击间的其他事件，故这里不做处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里可以看出，在单击时，会回调OnPhotoTapListener和OnViewTapListener，然后将坐标回调出去，如果是双击，则根据当前缩放比来判定现在的缩放比然后通过<code>setScale</code>设置缩放比以及敲击的坐标。单击操作我们并不怎么关心，我们更关心双击的缩放操作，于是，查看<code>setScale</code>源码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScale</span><span class="params">(<span class="keyword">float</span> scale, <span class="keyword">float</span> focalX, <span class="keyword">float</span> focalY,</span><br><span class="line">                     <span class="keyword">boolean</span> animate)</span> </span>&#123;</span><br><span class="line">    ImageView imageView = getImageView();<span class="comment">//获取ImageView</span></span><br><span class="line">      <span class="comment">//..</span></span><br><span class="line">      <span class="comment">//省略了部分源码</span></span><br><span class="line">        <span class="comment">//是否需要动画</span></span><br><span class="line">        <span class="keyword">if</span> (animate) &#123;</span><br><span class="line">            imageView.post(<span class="keyword">new</span> AnimatedZoomRunnable(getScale(), scale,</span><br><span class="line">                    focalX, focalY));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置给mSuppMatrix矩阵</span></span><br><span class="line">            mSuppMatrix.setScale(scale, scale, focalX, focalY);</span><br><span class="line">            checkAndDisplayMatrix();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>setScale</code>的源码还是比较简单的，如果不需要动画，直接设置给mSuppMatrix，然后进行检查显示。如果需要动画的话，就执行<code>AnimatedZoomRunnable</code>。<code>AnimatedZoomRunnable</code>实现了<code>Runnable</code>接口，主要实现代码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimatedZoomRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> mFocalX, mFocalY;<span class="comment">//焦点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mStartTime;<span class="comment">//开始时间</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> mZoomStart, mZoomEnd;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AnimatedZoomRunnable</span><span class="params">(<span class="keyword">final</span> <span class="keyword">float</span> currentZoom, <span class="keyword">final</span> <span class="keyword">float</span> targetZoom,</span><br><span class="line">                                    <span class="keyword">final</span> <span class="keyword">float</span> focalX, <span class="keyword">final</span> <span class="keyword">float</span> focalY)</span> </span>&#123;</span><br><span class="line">            mFocalX = focalX;</span><br><span class="line">            mFocalY = focalY;</span><br><span class="line">            mStartTime = System.currentTimeMillis();</span><br><span class="line">            mZoomStart = currentZoom;</span><br><span class="line">            mZoomEnd = targetZoom;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ImageView imageView = getImageView();</span><br><span class="line">            <span class="keyword">if</span> (imageView == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> t = interpolate();<span class="comment">//获取当前的时间插值</span></span><br><span class="line">            <span class="keyword">float</span> scale = mZoomStart + t * (mZoomEnd - mZoomStart);<span class="comment">//根据插值，获取当前时间的缩放值</span></span><br><span class="line">            <span class="keyword">float</span> deltaScale = scale / getScale();<span class="comment">//获取缩放比，大于1表示在放大，小于1在缩小。deltaScale * getScale() = scale</span></span><br><span class="line">           <span class="comment">//回调出去,deltaScale表示相对上次要缩放的比例</span></span><br><span class="line">            onScale(deltaScale, mFocalX, mFocalY);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="number">1f</span>) &#123;<span class="comment">//插值小于1表示没有缩放完成，通过不停post进行执行动画</span></span><br><span class="line">                Compat.postOnAnimation(imageView, <span class="keyword">this</span>);<span class="comment">//Compat根据版本做了兼容处理，小于4.2用了   view.postDelayed，大于等于4.2用了view.postOnAnimation。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="comment">//计算当前时间的插值        </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">interpolate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">float</span> t = <span class="number">1.0F</span> * (<span class="keyword">float</span>)(System.currentTimeMillis() - <span class="keyword">this</span>.mStartTime) / (<span class="keyword">float</span>)PhotoViewAttacher.<span class="keyword">this</span>.ZOOM_DURATION;</span><br><span class="line">            t = Math.min(<span class="number">1.0F</span>, t);</span><br><span class="line">            t = PhotoViewAttacher.sInterpolator.getInterpolation(t);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>onScale</code>的相关源码如下，可以看出，调用了<code>mSuppMatrix.postScale</code>和<code>checkAndDisplayMatrix()</code>来进行显示缩放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScale</span><span class="params">(<span class="keyword">float</span> scaleFactor, <span class="keyword">float</span> focusX, <span class="keyword">float</span> focusY)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((getScale() &lt; mMaxScale || scaleFactor &lt; <span class="number">1f</span>) &amp;&amp; (getScale() &gt; mMinScale || scaleFactor &gt; <span class="number">1f</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != mScaleChangeListener) &#123;</span><br><span class="line">            <span class="comment">//监听</span></span><br><span class="line">            mScaleChangeListener.onScaleChange(scaleFactor, focusX, focusY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缩放</span></span><br><span class="line">        mSuppMatrix.postScale(scaleFactor, scaleFactor, focusX, focusY);</span><br><span class="line">        checkAndDisplayMatrix();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>双击缩放中的动画缩放的流程是这样的，首先会记录一个开始时间<code>mStartTime</code>,然后根据当前时间来获取插值<code>interpolate()</code>以便了解当前应该处于的进度，根据插值求出当前的缩放值<code>scale</code>，然后与上次相比求出缩放比差值<code>deltaScale</code>，然后通过<code>onScale</code>回调出去，最终通过Compat.postOnAnimation来执行这个Runable，如此反复直到插值为1，缩放到目标值为止。</p>
<h3 id="双指缩放及拖拽"><a href="#双指缩放及拖拽" class="headerlink" title="双指缩放及拖拽"></a>双指缩放及拖拽</h3><p>双击缩放的相关源码到此为止，接下来看看通过双指缩放与拖拽的实现源码。即<code>VersionedGestureDetector.newInstance(imageView.getContext(), this);</code>这句。<br>VersionedGestureDetector看名字便知道又做了版本兼容处理。里面只有一个静态方法<code>newInstance</code>,源码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据版本进行了控制   </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionedGestureDetector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GestureDetector <span class="title">newInstance</span><span class="params">(Context context,</span><br><span class="line">                                              OnGestureListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> sdkVersion = Build.VERSION.SDK_INT;</span><br><span class="line">        GestureDetector detector;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sdkVersion &lt; Build.VERSION_CODES.ECLAIR) &#123;</span><br><span class="line">            <span class="comment">//小于Android 2.0</span></span><br><span class="line">            detector = <span class="keyword">new</span> CupcakeGestureDetector(context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sdkVersion &lt; Build.VERSION_CODES.FROYO) &#123;</span><br><span class="line">            <span class="comment">//小于Android 2.2</span></span><br><span class="line">            detector = <span class="keyword">new</span> EclairGestureDetector(context);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            detector = <span class="keyword">new</span> FroyoGestureDetector(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        detector.setOnGestureListener(listener);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> detector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>newInstance</code>中传入了OnGestureListener，这个<code>OnGestureListener</code>是自定义的接口，源码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnGestureListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拖拽时回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDrag</span><span class="params">(<span class="keyword">float</span> dx, <span class="keyword">float</span> dy)</span></span>;</span><br><span class="line">    <span class="comment">//Fling时回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFling</span><span class="params">(<span class="keyword">float</span> startX, <span class="keyword">float</span> startY, <span class="keyword">float</span> velocityX,</span><br><span class="line">                 <span class="keyword">float</span> velocityY)</span></span>;</span><br><span class="line">    <span class="comment">//缩放时回调，`onScale`在双击动画缩放时已经介绍过了，scaleFactor表示相对于上次的缩放比</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onScale</span><span class="params">(<span class="keyword">float</span> scaleFactor, <span class="keyword">float</span> focusX, <span class="keyword">float</span> focusY)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，回调了缩放、Fling和拖拽三种情况。现在我们回到<code>newInstance</code>相关源码，可以看出有三种探测器<code>CupcakeGestureDetector</code>、<code>EclairGestureDetector</code>和<code>FroyoGestureDetector</code>。且三者是相互继承的关系，<code>FroyoGestureDetector</code>继承于<code>EclairGestureDetector</code>，<code>EclairGestureDetector</code>继承于<code>CupcakeGestureDetector</code>。<br>其中CupcakeGestureDetector和EclairGestureDetector不支持双指缩放。由于Android2.0以下不支持多点触控，于是<code>CupcakeGestureDetector</code>核心源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getActiveX</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ev.getX();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getActiveY</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ev.getY();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">           <span class="comment">//添加速度探测器</span></span><br><span class="line">            mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != mVelocityTracker) &#123;</span><br><span class="line">                mVelocityTracker.addMovement(ev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LogManager.getLogger().i(LOG_TAG, <span class="string">"Velocity tracker is null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取坐标</span></span><br><span class="line">            mLastTouchX = getActiveX(ev);</span><br><span class="line">            mLastTouchY = getActiveY(ev);</span><br><span class="line">            mIsDragging = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = getActiveX(ev);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y = getActiveY(ev);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> dx = x - mLastTouchX, dy = y - mLastTouchY;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mIsDragging) &#123;</span><br><span class="line">                <span class="comment">//如果手指移动的距离大于mTouchSlop，表示在拖拽</span></span><br><span class="line">                mIsDragging = Math.sqrt((dx * dx) + (dy * dy)) &gt;= mTouchSlop;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mIsDragging) &#123;<span class="comment">//如果在拖拽，就回调出去</span></span><br><span class="line">                mListener.onDrag(dx, dy);</span><br><span class="line">                mLastTouchX = x;</span><br><span class="line">                mLastTouchY = y;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != mVelocityTracker) &#123;</span><br><span class="line">                    mVelocityTracker.addMovement(ev);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != mVelocityTracker) &#123;</span><br><span class="line">                mVelocityTracker.recycle();</span><br><span class="line">                mVelocityTracker = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            <span class="comment">//手指抬起时，如果之前在拖拽</span></span><br><span class="line">            <span class="keyword">if</span> (mIsDragging) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != mVelocityTracker) &#123;</span><br><span class="line">                    mLastTouchX = getActiveX(ev);</span><br><span class="line">                    mLastTouchY = getActiveY(ev);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//计算滑动速度</span></span><br><span class="line">                    mVelocityTracker.addMovement(ev);</span><br><span class="line">                    mVelocityTracker.computeCurrentVelocity(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> vX = mVelocityTracker.getXVelocity(), vY = mVelocityTracker</span><br><span class="line">                            .getYVelocity();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果大于最小的Fling速度，就回调出去</span></span><br><span class="line">                    <span class="keyword">if</span> (Math.max(Math.abs(vX), Math.abs(vY)) &gt;= mMinimumVelocity) &#123;</span><br><span class="line">                        mListener.onFling(mLastTouchX,、mLastTouchY, -vX,-vY);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回收速度探测器</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != mVelocityTracker) &#123;</span><br><span class="line">                mVelocityTracker.recycle();</span><br><span class="line">                mVelocityTracker = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从源码可以看出<code>CupcakeGestureDetector</code>实现了拖拽和Fling效果。<code>EclairGestureDetector</code>用于Android 2.2以下，主要修正了多点触控的问题，因为当双指触控时，我们需要获取的是最后一个手指离开屏幕时的坐标，因此需要使getActiveX/getActiveY指向正确的点。源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">float</span> <span class="title">getActiveX</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> ev.getX(mActivePointerIndex);<span class="comment">//mActivePointerIndex为手指的索引。根据当前手指的索引获取坐标</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">return</span> ev.getX();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">float</span> <span class="title">getActiveY</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> ev.getY(mActivePointerIndex);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">return</span> ev.getY();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">       <span class="keyword">switch</span> (action &amp; MotionEvent.ACTION_MASK) &#123;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">               mActivePointerId = ev.getPointerId(<span class="number">0</span>);<span class="comment">//第一根手指的id</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">               mActivePointerId = INVALID_POINTER_ID;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_POINTER_UP:</span><br><span class="line">               <span class="comment">//获取某一根手指抬起时的索引</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> pointerIndex = Compat.getPointerIndex(ev.getAction()); </span><br><span class="line">               <span class="comment">//根据索引获取id</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> pointerId = ev.getPointerId(pointerIndex);</span><br><span class="line">               <span class="keyword">if</span> (pointerId == mActivePointerId) &#123;<span class="comment">//如果是抬起的是第一根手指</span></span><br><span class="line">                   <span class="comment">//那么对应获取第二点</span></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> newPointerIndex = pointerIndex == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                   mActivePointerId = ev.getPointerId(newPointerIndex);<span class="comment">//将id指向第二根手指</span></span><br><span class="line">                   <span class="comment">//获取第二根手指的当前坐标</span></span><br><span class="line">                   mLastTouchX = ev.getX(newPointerIndex);</span><br><span class="line">                   mLastTouchY = ev.getY(newPointerIndex);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//将索引指向后抬起的手指</span></span><br><span class="line">       mActivePointerIndex = ev</span><br><span class="line">               .findPointerIndex(mActivePointerId != INVALID_POINTER_ID ? mActivePointerId</span><br><span class="line">                       : <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(ev);<span class="comment">//按照`CupcakeGestureDetector`的逻辑处理</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>FroyoGestureDetector</code>用于Android 2.2以上，此时系统已经提供了一个缩放探索器，于是在拖拽和Fling的基础上，添加了双指缩放功能，核心源码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ScaleGestureDetector.OnScaleGestureListener mScaleListener = <span class="keyword">new</span> ScaleGestureDetector.OnScaleGestureListener() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScale</span><span class="params">(ScaleGestureDetector detector)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">float</span> scaleFactor = detector.getScaleFactor();<span class="comment">//获取相比于当其缩放值的缩放比例</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (Float.isNaN(scaleFactor) || Float.isInfinite(scaleFactor))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//回调出去。</span></span><br><span class="line">               mListener.onScale(scaleFactor,</span><br><span class="line">                       detector.getFocusX(), detector.getFocusY());</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        <span class="comment">//省略了部分源码</span></span><br></pre></td></tr></table></figure></p>
<p>图片的缩放与拖拽并没有在探测器中实现，而是回调到了PhotoViewAttacher中，PhotoViewAttacher实现了OnGestureListener接口，相关处理如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//拖拽回调</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrag</span><span class="params">(<span class="keyword">float</span> dx, <span class="keyword">float</span> dy)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mScaleDragDetector.isScaling()) &#123;</span><br><span class="line">           <span class="keyword">return</span>; <span class="comment">// 如果正在缩放，不许做其他操作</span></span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">//根剧拖拽进行平移</span></span><br><span class="line">       ImageView imageView = getImageView();</span><br><span class="line">       mSuppMatrix.postTranslate(dx, dy);</span><br><span class="line">       checkAndDisplayMatrix();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断父布局是不是可以拦截这一拖拽行为</span></span><br><span class="line">       ViewParent parent = imageView.getParent();</span><br><span class="line">       <span class="keyword">if</span> (mAllowParentInterceptOnEdge &amp;&amp; !mScaleDragDetector.isScaling() &amp;&amp; !mBlockParentIntercept) &#123;</span><br><span class="line">           <span class="comment">//如果没有阻止父布局拦截且图片已显示在相关边缘内，就允许拦截</span></span><br><span class="line">           <span class="keyword">if</span> (mScrollEdge == EDGE_BOTH</span><br><span class="line">                   || (mScrollEdge == EDGE_LEFT &amp;&amp; dx &gt;= <span class="number">1f</span>)</span><br><span class="line">                   || (mScrollEdge == EDGE_RIGHT &amp;&amp; dx &lt;= -<span class="number">1f</span>)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">null</span> != parent) &#123;</span><br><span class="line">                   parent.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//否则不允许拦截</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != parent) &#123;</span><br><span class="line">               parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Fling回调</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFling</span><span class="params">(<span class="keyword">float</span> startX, <span class="keyword">float</span> startY, <span class="keyword">float</span> velocityX,</span><br><span class="line">                       <span class="keyword">float</span> velocityY)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       ImageView imageView = getImageView();</span><br><span class="line">       mCurrentFlingRunnable = <span class="keyword">new</span> FlingRunnable(imageView.getContext());</span><br><span class="line">        <span class="comment">//传入fling的速度与View的宽高</span></span><br><span class="line">       mCurrentFlingRunnable.fling(getImageViewWidth(imageView),getImageViewHeight(imageView), (<span class="keyword">int</span>) velocityX, (<span class="keyword">int</span>) velocityY);</span><br><span class="line">               </span><br><span class="line">       imageView.post(mCurrentFlingRunnable);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>FlingRunnable</code>的源码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FlingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScrollerProxy mScroller;<span class="comment">//Scroller这里做了版本兼容处理，API小于9时用了PreGingerScroller（内部用了Scroller）,小于14用了GingerScroller（内部用了OverScroller），其他用了IcsScroller（内部用了OverScroller）。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentX, mCurrentY;<span class="comment">//当前坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlingRunnable</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mScroller = ScrollerProxy.getScroller(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelFling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mScroller.forceFinished(<span class="keyword">true</span>);<span class="comment">//停止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fling</span><span class="params">(<span class="keyword">int</span> viewWidth, <span class="keyword">int</span> viewHeight, <span class="keyword">int</span> velocityX, <span class="keyword">int</span> velocityY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> RectF rect = getDisplayRect();<span class="comment">//获取图片的显示区域</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == rect) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//水平方向上</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> startX = Math.round(-rect.left);<span class="comment">//四舍五入，左边的x坐标</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> minX, maxX, minY, maxY;<span class="comment">//Fling的边界值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (viewWidth &lt; rect.width()) &#123;<span class="comment">//如果图片的宽度大于View宽时就计算X的边界。</span></span><br><span class="line">            minX = <span class="number">0</span>;</span><br><span class="line">            maxX = Math.round(rect.width() - viewWidth);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minX = maxX = startX;<span class="comment">//如果图片宽小于View宽，就将三者设为一样。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//竖直方向上</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> startY = Math.round(-rect.top);</span><br><span class="line">        <span class="keyword">if</span> (viewHeight &lt; rect.height()) &#123;<span class="comment">//如果显示矩形高大于View的高。就计算边界</span></span><br><span class="line">            minY = <span class="number">0</span>;</span><br><span class="line">            maxY = Math.round(rect.height() - viewHeight);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minY = maxY = startY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCurrentX = startX;</span><br><span class="line">        mCurrentY = startY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 mScroller.fling</span></span><br><span class="line">        <span class="keyword">if</span> (startX != maxX || startY != maxY) &#123;</span><br><span class="line">            mScroller.fling(startX, startY, velocityX, velocityY, minX,</span><br><span class="line">                    maxX, minY, maxY, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mScroller.isFinished()) &#123;</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ImageView imageView = getImageView();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != imageView &amp;&amp; mScroller.computeScrollOffset()) &#123;</span><br><span class="line">           <span class="comment">//获取当前的位置</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> newX = mScroller.getCurrX();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> newY = mScroller.getCurrY();</span><br><span class="line">            <span class="comment">//将平移差值应用到mSuppMatrix</span></span><br><span class="line">            mSuppMatrix.postTranslate(mCurrentX - newX, mCurrentY - newY);</span><br><span class="line">            setImageViewMatrix(getDrawMatrix());<span class="comment">//应用到矩阵</span></span><br><span class="line"></span><br><span class="line">            mCurrentX = newX;</span><br><span class="line">            mCurrentY = newY;</span><br><span class="line"></span><br><span class="line">            Compat.postOnAnimation(imageView, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样，利用了<code>Compat.postOnAnimation</code>不停执行Runable来实现Fling惯性滚动效果。<br>关于PhotoViewAttacher的相关源码已经解读完毕，而该库中的空间PhotoView的实现也是依赖于PhotoViewAttacher，在<code>onDetachedFromWindow</code>中会自动回收资源，核心源码如下，其他就不做详细介绍了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PhotoView</span><span class="params">(Context context, AttributeSet attr, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(context, attr, defStyle);</span><br><span class="line">     <span class="keyword">super</span>.setScaleType(ScaleType.MATRIX);</span><br><span class="line">     <span class="keyword">this</span>.init();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//初始化</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">null</span> == <span class="keyword">this</span>.mAttacher || <span class="keyword">null</span> == <span class="keyword">this</span>.mAttacher.getImageView()) &#123;</span><br><span class="line">         <span class="keyword">this</span>.mAttacher = <span class="keyword">new</span> PhotoViewAttacher(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">null</span> != <span class="keyword">this</span>.mPendingScaleType) &#123;</span><br><span class="line">         <span class="keyword">this</span>.setScaleType(<span class="keyword">this</span>.mPendingScaleType);</span><br><span class="line">         <span class="keyword">this</span>.mPendingScaleType = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//调用回收cleanup</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.mAttacher.cleanup();</span><br><span class="line">     <span class="keyword">super</span>.onDetachedFromWindow();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//初始化</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.init();</span><br><span class="line">     <span class="keyword">super</span>.onAttachedToWindow();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感觉最近写东西越来越啰嗦了，需要练习着把话讲的简练一点，下一期源码解读：Gson。</p>
<hr>
<p>本期解读到此结束，如有错误之处，欢迎指出。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/07/03/Gson-源码解读/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Gson 源码解读
        
      </div>
    </a>
  
  
    <a href="/2016/06/21/Android-Matrix矩阵详解/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Android Matrix矩阵详解</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="PhotoView-源码解读" data-title="PhotoView 源码解读" data-url="http://www.maplejaw.com/2016/06/27/PhotoView-源码解读/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"maplejaw"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 maplejaw
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>