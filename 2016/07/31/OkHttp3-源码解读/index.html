<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>OkHttp3 源码解读 | maplejaw的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="开源库地址：https://github.com/square/okhttp解读版本：3.4.1
Okhttp是目前非常流行的网络请求库，出自Square公司。对于该库的使用，相信大家已经比较熟悉了。今天，我将从源码角度对Okhttp3进行剖析。
基本使用Okhttp的使用可以分为四步：

初始化客户端（实际应用中应当保持单例）
1234//获取一个客户端OkHttpClient client =">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp3 源码解读">
<meta property="og:url" content="http://www.maplejaw.com/2016/07/31/OkHttp3-源码解读/index.html">
<meta property="og:site_name" content="maplejaw的技术博客">
<meta property="og:description" content="开源库地址：https://github.com/square/okhttp解读版本：3.4.1
Okhttp是目前非常流行的网络请求库，出自Square公司。对于该库的使用，相信大家已经比较熟悉了。今天，我将从源码角度对Okhttp3进行剖析。
基本使用Okhttp的使用可以分为四步：

初始化客户端（实际应用中应当保持单例）
1234//获取一个客户端OkHttpClient client =">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/umzjlxfr5q1tudj1hvjjunfg/okhttp_full_process.png">
<meta property="og:updated_time" content="2016-07-31T12:10:15.393Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OkHttp3 源码解读">
<meta name="twitter:description" content="开源库地址：https://github.com/square/okhttp解读版本：3.4.1
Okhttp是目前非常流行的网络请求库，出自Square公司。对于该库的使用，相信大家已经比较熟悉了。今天，我将从源码角度对Okhttp3进行剖析。
基本使用Okhttp的使用可以分为四步：

初始化客户端（实际应用中应当保持单例）
1234//获取一个客户端OkHttpClient client =">
<meta name="twitter:image" content="http://static.zybuluo.com/maplejaw/umzjlxfr5q1tudj1hvjjunfg/okhttp_full_process.png">
  
    <link rel="alternative" href="/atom.xml" title="maplejaw的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/uploads/avatar.jpeg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">maplejaw</a></h1>
		</hgroup>

		
		<p class="header-subtitle">不忘初心，方得始终</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">归档</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/maplejaw" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/python/" style="font-size: 14px;">python</a> <a href="/tags/开源库/" style="font-size: 10px;">开源库</a> <a href="/tags/插件化探索/" style="font-size: 16px;">插件化探索</a> <a href="/tags/源码解读/" style="font-size: 18px;">源码解读</a> <a href="/tags/知识整理/" style="font-size: 12px;">知识整理</a> <a href="/tags/自定义View/" style="font-size: 10px;">自定义View</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">maplejaw</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img src="/uploads/avatar.jpeg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
			</div>
			<hgroup>
			  <h1 class="header-author">maplejaw</h1>
			</hgroup>
			
			<p class="header-subtitle">不忘初心，方得始终</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">归档</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/maplejaw" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-OkHttp3-源码解读" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/31/OkHttp3-源码解读/" class="article-date">
  	<time datetime="2016-07-31T11:54:47.000Z" itemprop="datePublished">2016-07-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      OkHttp3 源码解读
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码解读/">源码解读</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>开源库地址：<a href="https://github.com/square/okhttp" target="_blank" rel="external">https://github.com/square/okhttp</a><br>解读版本：3.4.1</p>
<p>Okhttp是目前非常流行的网络请求库，出自Square公司。对于该库的使用，相信大家已经比较熟悉了。今天，我将从源码角度对Okhttp3进行剖析。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>Okhttp的使用可以分为四步：</p>
<ol>
<li><p>初始化客户端（实际应用中应当保持单例）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个客户端</span></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                 ...</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建Request</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//构建一个Request</span></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">     .url(url)</span><br><span class="line">     .build();</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取Call对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//获取Call对象</span></span><br><span class="line">Call call=client.newCall(request);</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送请求（execute同步/enqueue异步）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//同步调用</span></span><br><span class="line"> Response response = call.execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步调用</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<p>当然，在使用类似POST等可以设置请求体的请求方法时，我们还可以如下构建请求体。</p>
<p><strong>构建字符串，字节，文件请求体：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType TEXT = MediaType.parse(<span class="string">"text/plain; charset=utf-8"</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType STREAM = MediaType.parse(<span class="string">"application/octet-stream"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//构建字符串请求体</span></span><br><span class="line"> RequestBody body1 = RequestBody.create(TEXT, string);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//构建字节请求体</span></span><br><span class="line"> RequestBody body2 = RequestBody.create(STREAM, <span class="keyword">byte</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//构建文件请求体</span></span><br><span class="line"> RequestBody body3 = RequestBody.create(STREAM, file);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="comment">//将请求体设置给请求方法内</span></span><br><span class="line"> Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .post(xx)<span class="comment">// xx表示body1，body2，body3中的某一个</span></span><br><span class="line">      .build();</span><br></pre></td></tr></table></figure></p>
<p><strong>构建表单请求体：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建表单RequestBody</span></span><br><span class="line">RequestBody formBody=<span class="keyword">new</span> FormBody.Builder()</span><br><span class="line">                .add(<span class="string">"name"</span>,<span class="string">"maplejaw"</span>)</span><br><span class="line">                .add(<span class="string">"age"</span>,<span class="string">"18"</span>)</span><br><span class="line">                 ...     </span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure></p>
<p><strong>构建分块表单请求体：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType STREAM = MediaType.parse(<span class="string">"application/octet-stream"</span>);</span><br><span class="line"><span class="comment">//构建表单RequestBody</span></span><br><span class="line">RequestBody multipartBody=<span class="keyword">new</span> MultipartBody.Builder()</span><br><span class="line">               .setType(MultipartBody.FORM)<span class="comment">//指明为 multipart/form-data 类型</span></span><br><span class="line">               .addFormDataPart(<span class="string">"name"</span>,<span class="string">"maplejaw"</span>) <span class="comment">//添加表单数据</span></span><br><span class="line">               .addFormDataPart(<span class="string">"age"</span>,<span class="string">"20"</span>) <span class="comment">//添加表单数据</span></span><br><span class="line">               .addFormDataPart(<span class="string">"avatar"</span>,<span class="string">"111.jpg"</span>,RequestBody.create(STREAM,file)) <span class="comment">//添加文件,其中avatar为表单名，111.jpg为文件名。</span></span><br><span class="line">               .addPart(..)<span class="comment">//该方法用于添加自定义Part，一般来说以上已经够用</span></span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure></p>
<p>关于Okhttp的基本使用已经介绍完毕，在大多数情况下，只要掌握以上使用方法，就足以应付关于网络请求的日常使用。<br>接下来，将从源码角度剖析OkHttp这个网络框架，如果你到目前为止还弄不清请求行、状态行、请求头、响应头、请求体和响应体这些基本概念的话，建议先阅读<a href="http://www.jianshu.com/p/e544b7a76dac" target="_blank" rel="external">你应该知道的HTTP基础知识</a>这篇文章。</p>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="初始化OkHttpClient"><a href="#初始化OkHttpClient" class="headerlink" title="初始化OkHttpClient"></a>初始化OkHttpClient</h3><p>所谓初始化OkHttpClient，无非就是对其进行相关配置，在了解<code>OkHttpClient</code>相关配置前,先认识一下以下一些基本的类。<br><strong>Proxy</strong><br>代理类，默认有三种代理模式DIRECT(直连),HTTP（http代理）,SOCKS（socks代理），这三种模式，折腾过科学上网的或多或少都了解一点吧。<br><strong>ProxySelector</strong><br>代理选择类，默认不使用代理，即使用直连方式，当然，我们可以自定义配置，以指定URI使用某种代理，类似代理软件的PAC功能。<br><strong>Protocol</strong><br>协议类，用来表示使用的协议版本，比如<code>http/1.0</code>,<code>http/1.1</code>,<code>spdy/3.1</code>,<code>h2</code>等<br><strong>Dns</strong><br>DNS这里就不用介绍了，用于根据主机名来查询对应的IP。<br><strong>Cache</strong><br>缓存类，内部使用了DiskLruCache来进行管理缓存，匹配缓存的机制不仅仅是根据url，而且会根据请求方法和请求头来验证是否可以响应缓存。此外，仅支持GET请求的缓存。<br><strong>ConnectionSpec</strong><br>连接规范，用于配置Socket连接层。对于HTTPS，还能配置安全传输层协议（TLS）版本和密码套件（CipherSuite）<br><strong>Interceptor</strong><br>拦截器，该类的功能还是比较强大的，通过拦截器可以监视、重写和重试请求。拦截器的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Connection <span class="title">connection</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>拦截器的使用也非常简单，如果你只是想修改Request，那么就通过<code>chain.request()</code>获取原始的Request然后进行修改，比如添加cookie，代理等请求头，甚至还能修改请求方法和请求体。同理如果需要修改Response,则可以通过<code>chain.proceed</code>来获取Response后进行修改。此外我们还可以在其中进行打印日志等其他监视行为。<br>关于拦截器的使用例子如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//通过addInterceptor添加拦截器</span></span><br><span class="line">  OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">               ...</span><br><span class="line">               .addInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">               .build();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//自定义拦截器              </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span> </span><br><span class="line">      <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           <span class="comment">//获取原始Request</span></span><br><span class="line">           Request request = chain.request(); </span><br><span class="line">           </span><br><span class="line">           <span class="comment">//构建新的Request</span></span><br><span class="line">           Request newRequest=request.newBuilder()<span class="comment">//使用newBuilder，在原来request基础上修改，当然如果暴力点，可以完全重写Request。</span></span><br><span class="line">                   .header(<span class="string">"User-Agent"</span>, <span class="string">"OkHttp Example"</span>)</span><br><span class="line">                   ...</span><br><span class="line">                   .build();</span><br><span class="line">         </span><br><span class="line">           <span class="comment">//获取Response</span></span><br><span class="line">           Response response = chain.proceed(newRequest);</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//构建新的Response</span></span><br><span class="line">           Response newResponse=response.newBuilder()</span><br><span class="line">                    .header(<span class="string">"Cache-Control"</span>, <span class="string">"max-age=60"</span>)</span><br><span class="line">                     ....</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> newResponse;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>CookieJar</strong><br>用来管理cookie，可以根据url保存cookie，也可以通过url取出相应cookie。默认的不做cookie管理。该接口中有两个抽象方法，用户可以自己实现该接口以对cookie进行管理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存cookie</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveFromResponse</span><span class="params">(HttpUrl url, List&lt;Cookie&gt; cookies)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据Url导入保存的Cookie</span></span><br><span class="line"><span class="function">List&lt;Cookie&gt; <span class="title">loadForRequest</span><span class="params">(HttpUrl url)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>SocketFactory</strong><br>Socket工厂，通过<code>createSocket</code>来创建Socket。<br><strong>SSLSocketFactory</strong><br>安全套接层工厂，HTTPS相关，用于创建SSLSocket。一般配置HTTPS证书信任问题都需要从这里着手。对于不受信任的证书一般会提示<code>javax.net.ssl.SSLHandshakeException</code>异常。配置信任所有证书的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">            .sslSocketFactory(getTrustAllSSLSocketFactory())<span class="comment">//配置SSL工厂</span></span><br><span class="line">            .build();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取信任所有证书的SSLSocketFactory</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SSLSocketFactory <span class="title">getTrustAllSSLSocketFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 信任所有证书</span></span><br><span class="line">    TrustManager[] trustAllCerts = <span class="keyword">new</span> TrustManager[]&#123;<span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> X509Certificate[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] certs, String authType)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] certs, String authType)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SSLContext sslContext = SSLContext.getInstance(<span class="string">"TLS"</span>);</span><br><span class="line">        sslContext.init(<span class="keyword">null</span>, trustAllCerts, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> sslContext.getSocketFactory();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于信任自证书的配置问题，可以参考<a href="http://blog.csdn.net/lmj623565791/article/details/48129405" target="_blank" rel="external">Android Https相关完全解析 当OkHttp遇到Https</a>。这篇文章。<br><strong>CertificateChainCleaner</strong><br>证书链清洁器，HTTPS相关，用于从Java的TLS API构建的原始数组中统计有效的证书链，然后清除跟TLS握手不相关的证书，提取可信任的证书以便可以受益于证书锁机制。<br><strong>HostnameVerifier</strong><br>主机名验证器，与HTTPS中的SSL相关，当握手时如果URL的主机名不是可识别的主机，就会要求进行主机名验证。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HostnameVerifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//通过session验证指定的主机名是否被允许</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>CertificatePinner</strong><br>证书锁，HTTPS相关，用于约束哪些证书可以被信任，可以防止一些已知或未知的中间证书机构带来的攻击行为。如果所有证书都不被信任将抛出SSLPeerUnverifiedException异常。<br>其中用于检查证书是否被信任的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查证书是否被信任</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String hostname, List&lt;Certificate&gt; peerCertificates)</span></span><br><span class="line">      <span class="keyword">throws</span> SSLPeerUnverifiedException </span>&#123;</span><br><span class="line">    List&lt;Pin&gt; pins = findMatchingPins(hostname);<span class="comment">//获取Pin（网址，hash算法，hash值）</span></span><br><span class="line">    <span class="keyword">if</span> (pins.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (certificateChainCleaner != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//通过清洁器获取信任的证书</span></span><br><span class="line">       peerCertificates = certificateChainCleaner.clean(peerCertificates, hostname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>, certsSize = peerCertificates.size(); c &lt; certsSize; c++) &#123;</span><br><span class="line">      <span class="comment">//对证书进行比对hash值，如果配对失败就抛出SSLPeerUnverifiedException异常</span></span><br><span class="line">      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Lazily compute the hashes for each certificate.</span></span><br><span class="line">      ByteString sha1 = <span class="keyword">null</span>;</span><br><span class="line">      ByteString sha256 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, pinsSize = pins.size(); p &lt; pinsSize; p++) &#123;</span><br><span class="line">        Pin pin = pins.get(p);</span><br><span class="line">        <span class="keyword">if</span> (pin.hashAlgorithm.equals(<span class="string">"sha256/"</span>)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sha256 == <span class="keyword">null</span>) sha256 = sha256(x509Certificate);</span><br><span class="line">          <span class="keyword">if</span> (pin.hash.equals(sha256)) <span class="keyword">return</span>; <span class="comment">// Success!</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pin.hashAlgorithm.equals(<span class="string">"sha1/"</span>)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sha1 == <span class="keyword">null</span>) sha1 = sha1(x509Certificate);</span><br><span class="line">          <span class="keyword">if</span> (pin.hash.equals(sha1)) <span class="keyword">return</span>; <span class="comment">// Success!</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Authenticator</strong><br>身份认证器，当连接提示未授权时，可以通过重新设置请求头来响应一个新的Request。状态码401表示远程服务器请求授权，407表示代理服务器请求授权。该认证器在需要时会被RetryAndFollowUpInterceptor触发。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authenticator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Authenticator NONE = <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">authenticate</span><span class="params">(Route route, Response response)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">Request <span class="title">authenticate</span><span class="params">(Route route, Response response)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于授权的源码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticator</span> <span class="keyword">implements</span> <span class="title">Authenticator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Request <span class="title">authenticate</span><span class="params">(Route route, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           String credential = Credentials.basic(...)</span><br><span class="line"></span><br><span class="line">           Request.Builder builder=response.request().newBuilder();</span><br><span class="line">          </span><br><span class="line">           <span class="keyword">if</span>(response.code()==<span class="number">401</span>)&#123;</span><br><span class="line">               builder .header(<span class="string">"Authorization"</span>, credential);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(response.code()==<span class="number">407</span>)&#123;</span><br><span class="line">               builder .header(<span class="string">"Proxy-Authorization"</span>, credential);</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">           <span class="keyword">return</span>  builder.build();</span><br><span class="line">          </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>ConnectionPool</strong><br>连接池，用于管理HTTP和SPDY连接的复用以减少网络延迟，HTTP请求相同的Address时可以共享同一个连接。<br><strong>Cache</strong><br>见名之意，缓存类<br><strong>Dispatcher</strong><br>调度器，里面包含了线程池和三个队列（readyAsyncCalls：保存等待执行的异步请求；runningAsyncCalls：保存正在运行的异步请求；runningSyncCalls：保存正在执行的同步请求）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存准备运行的异步请求（当运行请求超过限制数时会保存在此队列）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"> <span class="comment">//保存正在运行的异步请求</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"> <span class="comment">//保存正在运行的同步请求</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>当请求执行完毕后，调用<code>finished</code>将请求从runningAsyncCalls队列中移除，并且检查readyAsyncCalls以继续提交在队列中准备的请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//移除执行完毕的请求</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!runningAsyncCalls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"AsyncCall wasn't running!"</span>);</span><br><span class="line">    promoteCalls();<span class="comment">//推进请求队列</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//推进请求</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">//容量已满，不提交新请求</span></span><br><span class="line">    <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// 没有正在准备的请求，返回</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//从readyAsyncCalls中循环取出AsyncCall直到达到容量上限</span></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        i.remove();</span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// 达到上限后返回</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>提交异步请求通过<code>enqueue</code>进行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//检查容量大小</span></span><br><span class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">    runningAsyncCalls.add(call);<span class="comment">//加入队列</span></span><br><span class="line">    executorService().execute(call);<span class="comment">//执行</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//超过容量大小后，加入准备队列中</span></span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于同步请求，由于不需要提交到线程池中执行，因此只需通过<code>executed</code>将其加入runningSyncCalls队列中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">  runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>阅读完上面的类后，对于OkHttpClient的构建就不会一脸蒙蔽了。OkHttpClient的Builder中的源码如下所示，可以了解一下默认值。当然这些值都可可以自行配置的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//调度器</span></span><br><span class="line">    dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">    <span class="comment">//默认支持的协议列表</span></span><br><span class="line">    protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">    <span class="comment">//默认的连接规范</span></span><br><span class="line">    connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">    <span class="comment">//默认的代理选择器（直连）</span></span><br><span class="line">    proxySelector = ProxySelector.getDefault();</span><br><span class="line">    <span class="comment">//默认不进行管理cookie</span></span><br><span class="line">    cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">    socketFactory = SocketFactory.getDefault();</span><br><span class="line">    <span class="comment">//主机验证</span></span><br><span class="line">    hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">    <span class="comment">//证书锁，默认不开启</span></span><br><span class="line">    certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">    <span class="comment">//默认不进行授权</span></span><br><span class="line">    proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">    authenticator = Authenticator.NONE;</span><br><span class="line">    <span class="comment">//初始化连接池</span></span><br><span class="line">    connectionPool = <span class="keyword">new</span> ConnectionPool();</span><br><span class="line">    <span class="comment">//DNS</span></span><br><span class="line">    dns = Dns.SYSTEM;</span><br><span class="line">    followSslRedirects = <span class="keyword">true</span>;</span><br><span class="line">    followRedirects = <span class="keyword">true</span>;</span><br><span class="line">    retryOnConnectionFailure = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">    readTimeout = <span class="number">10_000</span>;</span><br><span class="line">    writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="构建Request"><a href="#构建Request" class="headerlink" title="构建Request"></a>构建Request</h3><p>Request中主要有以下属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求的url</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> HttpUrl url;</span><br><span class="line"> <span class="comment">//请求方法,GET,POST等</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> String method;</span><br><span class="line"> <span class="comment">//请求头</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line"> <span class="comment">//请求体</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> RequestBody body;</span><br><span class="line"> <span class="comment">//该请求的标签</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Object tag;</span><br></pre></td></tr></table></figure></p>
<p><strong>HttpUrl</strong><br>其中HttpUrl用于规范普通的url连接，并解析url的组成成分。<br>先来了解一下url的构成；<br>scheme://username:password@host:port/pathSegment/pathSegment?queryParameter#fragment;</p>
<p>现通过如下例子来示范HttpUrl的使用：<br><a href="https://www.google.com/search?q=maplejaw" target="_blank" rel="external">https://www.google.com/search?q=maplejaw</a><br>使用parse解析url字符串：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpUrl url = HttpUrl.parse(<span class="string">"https://www.google.com/search?q=maplejaw"</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过构建者模式创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpUrl url = <span class="keyword">new</span> HttpUrl.Builder()</span><br><span class="line">        .scheme(<span class="string">"https"</span>)</span><br><span class="line">        .host(<span class="string">"www.google.com"</span>)</span><br><span class="line">        .addPathSegment(<span class="string">"search"</span>)</span><br><span class="line">        .addQueryParameter(<span class="string">"q"</span>, <span class="string">"maplejaw"</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure></p>
<p><strong>Headers</strong><br>Headers用于配置请求头，对于请求头配置大家一定不陌生吧，比如<code>Content-Type</code>,<code>User-Agent</code>和<code>Cache-Control</code>等等。<br>创建Headers也有两种方式。如下：<br>of创建：传入的数组必须是偶数对，否则会抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Headers.of(<span class="string">"name1"</span>,<span class="string">"value1"</span>,<span class="string">"name2"</span>,<span class="string">"value2"</span>,.....);</span><br></pre></td></tr></table></figure></p>
<p>构建者模式创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Headers mHeaders=<span class="keyword">new</span> Headers.Builder()</span><br><span class="line">           .set(<span class="string">"name1"</span>,<span class="string">"value1"</span>)<span class="comment">//set表示name1是唯一的，会覆盖掉已经存在的</span></span><br><span class="line">           .add(<span class="string">"name2"</span>,<span class="string">"value2"</span>)<span class="comment">//add不会覆盖已经存在的头，可以存在多个</span></span><br><span class="line">           .build();</span><br></pre></td></tr></table></figure></p>
<p>Headers内部使用了一个数组进行保存<code>private final String[] namesAndValues;</code>,你可能会想，为什么不用map呢？因为map有一个致命的缺点，它的key是唯一的。<br>但是用数组取值方法吗？可以很严肃的告诉你，非常方便，内部已经封装好。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> namesAndValues[index * <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> namesAndValues[index * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，通过toString转为字符串，以便写入请求头：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = size(); i &lt; size; i++) &#123;</span><br><span class="line">    result.append(name(i)).append(<span class="string">": "</span>).append(value(i)).append(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>RequestBody</strong><br>RequestBody也就是请求体了，对于请求体的创建在前面已经介绍过了，这里就仅仅看下源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBody</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//返回该请求体的 Content-Type</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> MediaType <span class="title">contentType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//返回请求体的大小（字节数），-1表示未知</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//写入内容，BufferedSink是Okio中的类，类似于java中的OutputStream</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(BufferedSink sink)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MediaType这个类主要用于指定请求体的Content-Type的MIME类型，此外还能指定字符集，默认为utf-8。<br>创建MediaType如下般简单，;左边为MIME类型，右边为字符集编码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MediaType.parse(<span class="string">"text/plain; charset=utf-8"</span>)</span><br></pre></td></tr></table></figure></p>
<p>前面我们提到了表单和分块表单类型的请求体，现在来看一下对应的核心源码：<br>FormBody：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FormBody</span> <span class="keyword">extends</span> <span class="title">RequestBody</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType CONTENT_TYPE = MediaType.parse(<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> MediaType <span class="title">contentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CONTENT_TYPE;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writeOrCountBytes(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(BufferedSink sink)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writeOrCountBytes(sink, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> ...      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出Content_Type为application/x-www-form-urlencoded，且通过<code>writeOrCountBytes</code>来计算请求体大小和将请求体写入BufferedSink。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">writeOrCountBytes</span><span class="params">(BufferedSink sink, <span class="keyword">boolean</span> countBytes)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> byteCount = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">   Buffer buffer;</span><br><span class="line">   <span class="keyword">if</span> (countBytes) &#123;<span class="comment">//计算大小</span></span><br><span class="line">     buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     buffer = sink.buffer();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//写入表单内容（name1=value1&amp;name2=value2&amp;...）</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = encodedNames.size(); i &lt; size; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (i &gt; <span class="number">0</span>) buffer.writeByte(<span class="string">'&amp;'</span>);</span><br><span class="line">     buffer.writeUtf8(encodedNames.get(i));</span><br><span class="line">     buffer.writeByte(<span class="string">'='</span>);</span><br><span class="line">     buffer.writeUtf8(encodedValues.get(i));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (countBytes) &#123;<span class="comment">//如果只是计算的话，请清空缓存</span></span><br><span class="line">     byteCount = buffer.size();</span><br><span class="line">     buffer.clear();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> byteCount;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>MultipartBody和FormBody大体上相同，主要区别在于<code>writeOrCountBytes</code>方法，分块表单主要是将每个块的大小进行累加来求出请求体大小，如果其中有一个块没有指定大小，就会返回-1。所以分块表单中如果包含文件，默认是无法计算出大小的，除非你自己给文件的RequestBody指定contentLength。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">writeOrCountBytes</span><span class="params">(BufferedSink sink, <span class="keyword">boolean</span> countBytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> byteCount = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">   Buffer byteCountBuffer = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (countBytes) &#123;</span><br><span class="line">     <span class="comment">//如果是计算大小的话，就new个</span></span><br><span class="line">     sink = byteCountBuffer = <span class="keyword">new</span> Buffer();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//循环块</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, partCount = parts.size(); p &lt; partCount; p++) &#123;</span><br><span class="line">     Part part = parts.get(p);</span><br><span class="line">     <span class="comment">//获取每个块的头</span></span><br><span class="line">     Headers headers = part.headers;</span><br><span class="line">     <span class="comment">//获取每个块的请求体</span></span><br><span class="line">     RequestBody body = part.body;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//写 --xxxxxxxxxx 边界     </span></span><br><span class="line">     sink.write(DASHDASH);</span><br><span class="line">     sink.write(boundary);</span><br><span class="line">     sink.write(CRLF);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//写块的头</span></span><br><span class="line">     <span class="keyword">if</span> (headers != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>, headerCount = headers.size(); h &lt; headerCount; h++) &#123;</span><br><span class="line">         sink.writeUtf8(headers.name(h))</span><br><span class="line">             .write(COLONSPACE)</span><br><span class="line">             .writeUtf8(headers.value(h))</span><br><span class="line">             .write(CRLF);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//写块的Content_Type</span></span><br><span class="line">     MediaType contentType = body.contentType();</span><br><span class="line">     <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">       sink.writeUtf8(<span class="string">"Content-Type: "</span>)</span><br><span class="line">           .writeUtf8(contentType.toString())</span><br><span class="line">           .write(CRLF);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//写块的大小</span></span><br><span class="line">     <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">     <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">       sink.writeUtf8(<span class="string">"Content-Length: "</span>)</span><br><span class="line">           .writeDecimalLong(contentLength)</span><br><span class="line">           .write(CRLF);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (countBytes) &#123;</span><br><span class="line">       <span class="comment">// We can't measure the body's size without the sizes of its components.</span></span><br><span class="line">       <span class="comment">//如果有个块没有这名大小，就返回-1.</span></span><br><span class="line">       byteCountBuffer.clear();</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     sink.write(CRLF);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//如果是计算大小就累加，否则写入BufferedSink</span></span><br><span class="line">     <span class="keyword">if</span> (countBytes) &#123;</span><br><span class="line">       byteCount += contentLength;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       body.writeTo(sink);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     sink.write(CRLF);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写 --xxxxxxxxxx-- 结束边界</span></span><br><span class="line">   sink.write(DASHDASH);</span><br><span class="line">   sink.write(boundary);</span><br><span class="line">   sink.write(DASHDASH);</span><br><span class="line">   sink.write(CRLF);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (countBytes) &#123;</span><br><span class="line">     byteCount += byteCountBuffer.size();</span><br><span class="line">     byteCountBuffer.clear();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> byteCount;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="处理Response"><a href="#处理Response" class="headerlink" title="处理Response"></a>处理Response</h3><p>为什么先介绍处理Response部分而不是<code>newCall</code>部分，是因为Request和Response相呼应，理解起来更加连贯一点。<br>Response类属性如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Request request;<span class="comment">//获取到此次Response的最终Request（所谓最终Request是因为Reque可能被拦截器处理过）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;<span class="comment">//协议版本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;<span class="comment">//响应码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String message; <span class="comment">//响应消息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handshake handshake;<span class="comment">//TLS握手记录，保存了客户端和服务器的证书，TLS版本，密码套件等</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Headers headers;<span class="comment">//响应头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResponseBody body;<span class="comment">//响应体</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Response networkResponse;<span class="comment">//从网络返回的Response，如果没有从网络读取，networkResponse值为Null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Response cacheResponse;<span class="comment">//从缓存读取的Response，如果没有从缓存中取，为Null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Response priorResponse;<span class="comment">//之前的Response,一般发生重定向或者重试时有值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sentRequestAtMillis;<span class="comment">//记录发送Request的时间戳（如果响应来自缓存，返回的时间戳为原始请求的时间）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> receivedResponseAtMillis;<span class="comment">//记录接收Response的时间戳（如果响应来自缓存，返回原始的响应时间）</span></span><br></pre></td></tr></table></figure></p>
<p>ResponseBody是一次性的流，所以不能重复读取，此外务必记得要关闭流。<br>ResponseBody中常用的读取方法有如下几种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="comment">//获取InputStream，读取完后手动进行close，一般用于下载文件中</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> InputStream <span class="title">byteStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> source().inputStream();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字节，此方法无需close,因为已经写入内存中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="keyword">long</span> contentLength = contentLength();</span><br><span class="line">   <span class="keyword">if</span> (contentLength &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Cannot buffer entire body for content length: "</span> + contentLength);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   BufferedSource source = source();</span><br><span class="line">   <span class="keyword">byte</span>[] bytes;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     bytes = source.readByteArray();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     Util.closeQuietly(source);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (contentLength != -<span class="number">1</span> &amp;&amp; contentLength != bytes.length) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Content-Length and stream length disagree"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bytes;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//获取String，此方法无需Close,已经写入内存中</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">string</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> String(bytes(), charset().name());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="构建Call"><a href="#构建Call" class="headerlink" title="构建Call"></a>构建Call</h3><p>现在再回到OkHttpClient这个类，如果你看过我之前关于Retrofit源码解读，那你一定知道OkHttpClient实现了<code>Call.Factory</code>接口,<code>Call.Factory</code>的作用之前已经介绍过了，抽象方法为<code>Call newCall(Request request);</code>，用于将Request转换为Call对象。<br>核心源码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们知道Call只是一个接口，而RealCall即为Call的一个实现。而我们最关心的无法在于两个点：同步调用,异步调用。<br>同步调用的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//加入Dispatcher中的runningSyncCalls队列</span></span><br><span class="line">    client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//通过拦截链获取Response</span></span><br><span class="line">    Response result = getResponseWithInterceptorChain();</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//从runningSyncCalls队列中移除</span></span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，核心的源码在<code>getResponseWithInterceptorChain</code>中，通过责任链模式进行添加拦截器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//构建全栈拦截器</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());<span class="comment">//自定义拦截器</span></span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);<span class="comment">//重试拦截器</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));<span class="comment">//桥接拦截器</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));<span class="comment">//缓存拦截器</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));<span class="comment">//连接拦截器</span></span><br><span class="line">  <span class="keyword">if</span> (!retryAndFollowUpInterceptor.isForWebSocket()) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());<span class="comment">//用户预定义的网络拦截器</span></span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(</span><br><span class="line">      retryAndFollowUpInterceptor.isForWebSocket()));<span class="comment">//调用服务拦截器</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//内部通过责任链模式来使用拦截器</span></span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</span><br><span class="line">      interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);<span class="comment">//获取Response</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RealInterceptorChain内部的责任链调用如下，可以看出，拦截器会依次对Chain进行处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpStream httpStream,</span><br><span class="line">    Connection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//获取Chain</span></span><br><span class="line">  RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(</span><br><span class="line">      interceptors, streamAllocation, httpStream, connection, index + <span class="number">1</span>, request);</span><br><span class="line">  <span class="comment">//获取当前拦截器</span></span><br><span class="line">  Interceptor interceptor = interceptors.get(index);</span><br><span class="line">  <span class="comment">//拦截器通过Chain获取Response</span></span><br><span class="line">  Response response = interceptor.intercept(next);</span><br><span class="line">  ....</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异步调用和同步调用基本相同,也是通过<code>getResponseWithInterceptorChain</code>来获取Response，只不过该操作是放在AsyncCall(实现了Runable接口)中提交给dispatcher执行的。</p>
<p>在了解一系列的拦截器前，我们再来认识一下其他几个类。<br><strong>HttpStream</strong><br>一个接口，源码如下。对应的实现有Http1xStream、Http2xStream。分别对应HTTP/1.1、HTTP/2和SPDY协议。我们可以大约知道，通过<code>writeRequestHeaders</code>开始写入请求头到服务器，<code>createRequestBody</code>用于获取写入流来写入请求体。<code>readResponseHeaders</code>用于读取响应头，<code>openResponseBody</code>用于打开一个响应体。关于相应实现的源码这里就不分析了，比较简单，无非就是读写操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> DISCARD_STREAM_TIMEOUT_MILLIS = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回一个output stream（如果RequestBody可以转为流）</span></span><br><span class="line">  <span class="function">Sink <span class="title">createRequestBody</span><span class="params">(Request request, <span class="keyword">long</span> contentLength)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//写请求头</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">writeRequestHeaders</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Flush Request</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">finishRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读响应头</span></span><br><span class="line">  Response.<span class="function">Builder <span class="title">readResponseHeaders</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回一个ResponseBody</span></span><br><span class="line">  <span class="function">ResponseBody <span class="title">openResponseBody</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>StreamAllocation</strong><br>流分配器，该类用于协调连接、流和请求三者之间的关系。通过调用<code>newStream</code>可以获取一个HttpStream实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpStream <span class="title">newStream</span><span class="params">(OkHttpClient client, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> connectTimeout = client.connectTimeoutMillis();</span><br><span class="line">  <span class="keyword">int</span> readTimeout = client.readTimeoutMillis();</span><br><span class="line">  <span class="keyword">int</span> writeTimeout = client.writeTimeoutMillis();</span><br><span class="line">  <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化HttpStream</span></span><br><span class="line">    HttpStream resultStream;</span><br><span class="line">    <span class="keyword">if</span> (resultConnection.framedConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//Http2xStream</span></span><br><span class="line">      resultStream = <span class="keyword">new</span> Http2xStream(client, <span class="keyword">this</span>, resultConnection.framedConnection);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//Http1xStream</span></span><br><span class="line">      resultConnection.socket().setSoTimeout(readTimeout);</span><br><span class="line">      resultConnection.source.timeout().timeout(readTimeout, MILLISECONDS);</span><br><span class="line">      resultConnection.sink.timeout().timeout(writeTimeout, MILLISECONDS);</span><br><span class="line">      resultStream = <span class="keyword">new</span> Http1xStream(</span><br><span class="line">          client, <span class="keyword">this</span>, resultConnection.source, resultConnection.sink);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      stream = resultStream;</span><br><span class="line">      <span class="keyword">return</span> resultStream;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取RealConnection的流程是这样的，首先尝试从连接池中获取可复用的连接，如果获取不到，才会初始化RealConnection开启一个新连接。</p>
<p>在了解了HttpStream和StreamAllocation后，现在来分析<code>getResponseWithInterceptorChain</code>中的所有的拦截器。<br><strong>RetryAndFollowUpInterceptor</strong><br>重试与重定向拦截器，用来实现重试和重定向功能，核心实现如下面源码，<br>不难发现，内部通过<code>while(true)</code>死循环来进行重试获取Response（有重试上限，超过会抛出异常）。<code>followUpRequest</code>主要用来根据响应码来判断属于哪种行为触发的重试和重定向（比如未授权，超时，重定向等），然后构建响应的Request进行下一次请求。当然，如果没有触发重新请求就会直接返回Response。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   Request request = chain.request();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//初始化流分配器 </span></span><br><span class="line">   streamAllocation = <span class="keyword">new</span> StreamAllocation(</span><br><span class="line">       client.connectionPool(), createAddress(request.url()));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">   Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//死循环</span></span><br><span class="line">     <span class="comment">//..</span></span><br><span class="line">     <span class="comment">//省略了部分源码</span></span><br><span class="line">     Response response = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">     </span><br><span class="line">        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">       releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">     </span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="comment">//..</span></span><br><span class="line">     <span class="comment">//省略了部分源码</span></span><br><span class="line">       releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">if</span> (releaseConnection) &#123;</span><br><span class="line">         streamAllocation.streamFailed(<span class="keyword">null</span>);</span><br><span class="line">         streamAllocation.release();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">     <span class="comment">//将上次的请求放入priorResponse中</span></span><br><span class="line">     <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">       response = response.newBuilder()</span><br><span class="line">           .priorResponse(priorResponse.newBuilder()</span><br><span class="line">               .body(<span class="keyword">null</span>)</span><br><span class="line">               .build())</span><br><span class="line">           .build();</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//检查是否触发重定向重试等条件，并返回Request</span></span><br><span class="line">     Request followUp = followUpRequest(response);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;<span class="comment">//null表示无需重试</span></span><br><span class="line">       <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">         streamAllocation.release();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> response;<span class="comment">//返回response</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//..</span></span><br><span class="line">     <span class="comment">//省略了部分源码</span></span><br><span class="line">      </span><br><span class="line">     request = followUp;</span><br><span class="line">     priorResponse = response;</span><br><span class="line">     <span class="comment">//while循环进行下次请求</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>BridgeInterceptor</strong><br>桥接拦截器，用于完善请求头，比如Content-Type、Content-Length、Host、Connection、Accept-Encoding、User-Agent等等，这些请求头不用用户一一设置，如果用户没有设置该库会检查并自动完善。此外，这里会进行加载和回调cookie。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request userRequest = chain.request();</span><br><span class="line">  Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">  RequestBody body = userRequest.body();</span><br><span class="line">  <span class="comment">//将用户没有写入请求头的内容自动补充进去，比如Content-Type、Content-Length、Host、Connection、Accept-Encoding、User-Agent等等</span></span><br><span class="line">  <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    MediaType contentType = body.contentType();</span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取cookie添加到请求头中</span></span><br><span class="line">  List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">  <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//将响应cookie回调出去供用户保存</span></span><br><span class="line">  HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">  Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">      .request(userRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//省略了部分源码</span></span><br><span class="line">    responseBuilder.headers(strippedHeaders);</span><br><span class="line">    responseBuilder.body(<span class="keyword">new</span> RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</span><br><span class="line">  <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>CacheInterceptor</strong><br>缓存拦截器，首先根据Request中获取缓存的Response，然后根据用于设置的缓存策略来进一步判断缓存的Response是否可用以及是否发送网络请求（<code>CacheControl.FORCE_CACHE</code>因为不会发送网络请求，所以networkRequest一定为空）。如果从网络中读取，此时再次根据缓存策略来决定是否缓存响应。<br>配置缓存策略的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .cacheControl(CacheControl.FORCE_NETWORK)</span><br><span class="line">                 .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">              .build();</span><br></pre></td></tr></table></figure></p>
<p>拦截器的核心实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//通过Request从缓存中获取Response</span></span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据请求头获取用户指定的缓存策略，并根据缓存策略来获取networkRequest，cacheResponse。cacheResponse为null表示当前策略就算有缓存也不读缓存</span></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest = strategy.networkRequest;<span class="comment">//表示发往网络的request，不请求网络应为null</span></span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;<span class="comment">//返回从缓存中读取的response</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//cacheResponse表示不读缓存，那么cacheCandidate不可用，关闭它</span></span><br><span class="line">      closeQuietly(cacheCandidate.body()); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    <span class="comment">//省略了部分源码</span></span><br><span class="line">    <span class="comment">//返回从缓存中读取的Response</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//..</span></span><br><span class="line">      <span class="comment">//省略了部分源码</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取网络Response</span></span><br><span class="line">      networkResponse = chain.proceed(networkRequest);</span><br><span class="line">   </span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HttpHeaders.hasBody(response)) &#123;</span><br><span class="line">      <span class="comment">//如果可以缓存（用户允许，响应也允许）就进行缓存到本地</span></span><br><span class="line">      CacheRequest cacheRequest = maybeCache(response, networkResponse.request(), cache);</span><br><span class="line">      response = cacheWritingResponse(cacheRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>ConnectInterceptor</strong><br>连接拦截器，用于打开一个连接到远程服务器。说白了就是通过StreamAllocation获取HttpStream和RealConnection对象，以便后续读写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  Request request = realChain.request();</span><br><span class="line">  StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">  <span class="comment">//获取HttpStream</span></span><br><span class="line">  HttpStream httpStream = streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br><span class="line">  <span class="comment">//获取RealConnection</span></span><br><span class="line">  RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpStream, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>CallServerInterceptor</strong><br>调用服务拦截器，拦截链中的最后一个拦截器，通过网络与调用服务器。通过HttpStream依次次进行写请求头、请求头（可选）、读响应头、读响应体。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  HttpStream httpStream = ((RealInterceptorChain) chain).httpStream();</span><br><span class="line">  StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation();</span><br><span class="line">  Request request = chain.request();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">  <span class="comment">//写请求头</span></span><br><span class="line">  httpStream.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">//写请求体</span></span><br><span class="line">    Sink requestBodyOut = httpStream.createRequestBody(request, request.body().contentLength());</span><br><span class="line">    BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">    request.body().writeTo(bufferedRequestBody);</span><br><span class="line">    bufferedRequestBody.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  httpStream.finishRequest();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取Response。</span></span><br><span class="line">  Response response = httpStream.readResponseHeaders()</span><br><span class="line">      .request(request)</span><br><span class="line">      .handshake(streamAllocation.connection().handshake())</span><br><span class="line">      .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket || response.code() != <span class="number">101</span>) &#123;</span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(httpStream.openResponseBody(response))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在网上发现一张关于OkHttp的完整工作流程图，画的非常好，偷了个懒直接拿来用了，感谢作者。图片出自<a href="http://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="external">http://blog.piasy.com/2016/07/11/Understand-OkHttp/</a><br><img src="http://static.zybuluo.com/maplejaw/umzjlxfr5q1tudj1hvjjunfg/okhttp_full_process.png" alt="okhttp_full_process.png-78.4kB"></p>
<hr>
<p>本期解读到此结束，如有错误之处，欢迎指出。下一期，RxJava。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/07/22/HttpURLConnection-源码解读/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">HttpURLConnection 源码解读</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="OkHttp3-源码解读" data-title="OkHttp3 源码解读" data-url="http://www.maplejaw.com/2016/07/31/OkHttp3-源码解读/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"maplejaw"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 maplejaw
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>