<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>RxJava 源码解读 | maplejaw的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="开源库地址：https://github.com/ReactiveX/RxJava解读版本：1.1.8
基本概念RxJava 是一个基于Java的响应式扩展实现: 即一个通过使用可观察序列来编写异步和基于事件的程序库。它扩展了观察者模式以支持数据/事件序列，您可以根据声明好的规则通过操作符将序列组合在一起，而不用去担心低级别的线程，同步，线程安全和并发数据结构的各种问题。
基本用法前面既然说了Rx">
<meta property="og:type" content="article">
<meta property="og:title" content="RxJava 源码解读">
<meta property="og:url" content="http://www.maplejaw.com/2016/08/31/RxJava-源码解读/index.html">
<meta property="og:site_name" content="maplejaw的技术博客">
<meta property="og:description" content="开源库地址：https://github.com/ReactiveX/RxJava解读版本：1.1.8
基本概念RxJava 是一个基于Java的响应式扩展实现: 即一个通过使用可观察序列来编写异步和基于事件的程序库。它扩展了观察者模式以支持数据/事件序列，您可以根据声明好的规则通过操作符将序列组合在一起，而不用去担心低级别的线程，同步，线程安全和并发数据结构的各种问题。
基本用法前面既然说了Rx">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/ms4tb91lnwh2m7d7fwwolu6n/image_1alc28ectmnu1nev16p11ibb1vs59.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/a6gv5s4cnyjmocokl6e0ebdp/image_1app9gp8iic0pbg1f7ilad1dhh9.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/iy00luh2zxa014sf7zmpxkvs/image_1alj8i1ub14ijermlrpnkflm9.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/hfcj5538jjhsxkjwref4a0yg/image_1alj9e198f3bdm1jab1m16mjvm.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/9w5cccmu3klgar218zuyf7gy/image_1aqol5tvc1vp1r9vv6p1bk4ha29.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/jgm1yk98lgfgy0bm54ty36gk/image_1aqomk4sa1rj311pm19r61au8171am.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/fk9wmt93xoam12kckxdf5u9t/image_1aqon9fnt10q9k3qpa9peh15sn13.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/auy4tdz8zz1l16o69cwmyyve/image_1aqqornshvri1q8i5b81j461lfj9.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/tiq1wtcqgs090n4mcmkr3sz7/image_1arcg8d13111k1df31ohe56d1lcp9.png">
<meta property="og:updated_time" content="2016-09-09T13:34:19.680Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RxJava 源码解读">
<meta name="twitter:description" content="开源库地址：https://github.com/ReactiveX/RxJava解读版本：1.1.8
基本概念RxJava 是一个基于Java的响应式扩展实现: 即一个通过使用可观察序列来编写异步和基于事件的程序库。它扩展了观察者模式以支持数据/事件序列，您可以根据声明好的规则通过操作符将序列组合在一起，而不用去担心低级别的线程，同步，线程安全和并发数据结构的各种问题。
基本用法前面既然说了Rx">
<meta name="twitter:image" content="http://static.zybuluo.com/maplejaw/ms4tb91lnwh2m7d7fwwolu6n/image_1alc28ectmnu1nev16p11ibb1vs59.png">
  
    <link rel="alternative" href="/atom.xml" title="maplejaw的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/uploads/avatar.jpeg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">maplejaw</a></h1>
		</hgroup>

		
		<p class="header-subtitle">不忘初心，方得始终</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">归档</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/maplejaw" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/RxJava/" style="font-size: 12px;">RxJava</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/python/" style="font-size: 14px;">python</a> <a href="/tags/开源库/" style="font-size: 10px;">开源库</a> <a href="/tags/插件化探索/" style="font-size: 16px;">插件化探索</a> <a href="/tags/源码解读/" style="font-size: 18px;">源码解读</a> <a href="/tags/知识整理/" style="font-size: 12px;">知识整理</a> <a href="/tags/自定义View/" style="font-size: 10px;">自定义View</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">maplejaw</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img src="/uploads/avatar.jpeg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
			</div>
			<hgroup>
			  <h1 class="header-author">maplejaw</h1>
			</hgroup>
			
			<p class="header-subtitle">不忘初心，方得始终</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">归档</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/maplejaw" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-RxJava-源码解读" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/31/RxJava-源码解读/" class="article-date">
  	<time datetime="2016-08-31T14:52:13.000Z" itemprop="datePublished">2016-08-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      RxJava 源码解读
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码解读/">源码解读</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>开源库地址：<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">https://github.com/ReactiveX/RxJava</a><br>解读版本：1.1.8</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>RxJava 是一个基于Java的响应式扩展实现: 即一个通过使用可观察序列来编写异步和基于事件的程序库。<br>它扩展了观察者模式以支持数据/事件序列，您可以根据声明好的规则通过操作符将序列组合在一起，而不用去担心低级别的线程，同步，线程安全和并发数据结构的各种问题。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>前面既然说了RxJava扩展了观察者模式，也就是说，RxJava是采用观察者模式实现的。既然是观察者模式，那么一定需要两个东西，被观察者和观察者。<br><a id="more"></a><br><strong>怎么初始化一个观察者？(以下例子以订阅String类型为例子)</strong><br>我们可以直接使用<code>Observer</code>来初始化，<code>Observer</code>是一个接口，里面有<code>onNext</code>,<code>onCompleted</code>,<code>onError</code>三个抽象方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;String&gt; observer=<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">//正常终止时调用，onError和onCompleted只会通知一个</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//当Observable遇到错误或者无法返回期望的数据时会调用这个方法，后续不会再调用onNext和onCompleted</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//Observable调用这个方法发射数据</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure></p>
<p>此外我们可以使用<code>Observer</code>的子类<code>Subscriber</code>来初始化。<code>Subscriber</code>相对于<code>Observer</code>增加了<code>onStart</code>和<code>unsubscribe</code>，事实上，即使你使用的是<code>Observer</code>，在内部仍然会被包装为<code>Subscriber</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;String&gt; subscriber=<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>怎么初始化一个被观察者？</strong><br>初始化被观察者使用<code>Observable</code>,在<code>call</code>内进行处理事件。可以看出call的参数为<code>Subscriber</code>,这也进一步证实了<code>Observer</code>会被包装为<code>Subscriber</code>。只要被观察者调用call方法，订阅者就可以接受到事件/数据了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; observable=Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">              subscriber.onNext(<span class="string">"hello"</span>);</span><br><span class="line">              subscriber.onNext(<span class="string">"welcome to china"</span>);</span><br><span class="line">              subscriber.onCompleted();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></p>
<p>那么问题来了，怎么建立一个订阅关系？<br>只需被观察者调用<code>Observable.subscribe(Subscriber)</code>即可。<br>于是整个流程是这样的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//被观察者</span></span><br><span class="line"> Observable&lt;String&gt; observable=Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">            subscriber.onNext(<span class="string">"hello"</span>);</span><br><span class="line">            subscriber.onNext(<span class="string">"welcome to china"</span>);</span><br><span class="line">            subscriber.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者  </span></span><br><span class="line">Observer&lt;String&gt; observer=<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Log.d(<span class="string">"JG"</span>,<span class="string">"onCompleted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">         Log.d(<span class="string">"JG"</span>,<span class="string">"onError"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"JG"</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//被观察者订阅观察者（实际应理解为观察者订阅被观察者。）</span></span><br><span class="line">  observable.subscribe(observer);</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下。<br><img src="http://static.zybuluo.com/maplejaw/ms4tb91lnwh2m7d7fwwolu6n/image_1alc28ectmnu1nev16p11ibb1vs59.png" alt="image_1alc28ectmnu1nev16p11ibb1vs59.png-12.6kB"></p>
<p>此外，该库还有非常完善的异常捕获机制，当在处理数据时发生异常，可以自动捕获并回调到<code>onError</code>中。将<code>observable</code>修改成如下后，进行测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; observable=Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">throw</span>  <span class="keyword">new</span> RuntimeException();<span class="comment">//模拟抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>测试结果如下：<br><img src="http://static.zybuluo.com/maplejaw/a6gv5s4cnyjmocokl6e0ebdp/image_1app9gp8iic0pbg1f7ilad1dhh9.png" alt="image_1app9gp8iic0pbg1f7ilad1dhh9.png-4.1kB"></p>
<p>OK，基本用法已经介绍完了，接下来，本篇将深入源码内部一探究竟（除了操作符，下篇会对操作符进行完全解析，如果只对操作符感兴趣敬请期待下篇）。如果你只是刚接触RxJava，请看<a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给 Android 开发者的 RxJava 详解</a>这篇文章。</p>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="观察者（Subscriber）"><a href="#观察者（Subscriber）" class="headerlink" title="观察者（Subscriber）"></a>观察者（Subscriber）</h3><p><code>Subscriber</code>提供了一种从被观察者接收推送数据和通知以及从被观察者中取消订阅的机制。<br>实现了Observer和Subscription接口，在Observer的基础上加入了onStart生命周期方法。该类属性如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> NOT_SET = Long.MIN_VALUE;<span class="comment">//未设置请求数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SubscriptionList subscriptions;<span class="comment">//订阅列表，一个存放订阅者（实现了Subscription接口）的列表,以便一同解除订阅</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subscriber&lt;?&gt; subscriber;<span class="comment">//订阅者</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Producer producer;<span class="comment">//生产者（用来处理反压），被观察和观察者之间的请求通道</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> requested = NOT_SET; <span class="comment">//请求数， 默认为Long.MIN_VALUE。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Subscriber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">Subscriber</span><span class="params">(Subscriber&lt;?&gt; subscriber, <span class="keyword">boolean</span> shareSubscriptions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subscriber = subscriber;</span><br><span class="line">        <span class="comment">//是否共享订阅列表</span></span><br><span class="line">        <span class="keyword">this</span>.subscriptions = shareSubscriptions &amp;&amp; subscriber != <span class="keyword">null</span> ? subscriber.subscriptions : <span class="keyword">new</span> SubscriptionList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    <span class="comment">//省略了部分源码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>从源码可以看出<code>Subscriber</code>内部包含了一个子<code>Subscriber</code>，可以共享同一个订阅列表。Producer用于建立被观察者和观察者间的可以指定请求数量的请求通道，一般用来配合解决反压问题（backpressure）。Producer是一个函数式接口,里面就一个抽象方法<code>void request(long n);</code>。<code>SubscriptionList</code>是一个订阅列表，以便将多个订阅者一起取消订阅。<br>关于设置Producer和请求数的源码如下：<br><strong>request(long n)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;<span class="comment">//必须大于等于0</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"number requested cannot be negative: "</span> + n);</span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    Producer producerToRequestFrom = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (producer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            producerToRequestFrom = producer;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没有producer的话就保存到Subscriber的requested值，会逐渐累加。</span></span><br><span class="line">            addToRequested(n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有producer就直接调用Producer的request。</span></span><br><span class="line">    producerToRequestFrom.request(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>setProducer</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducer</span><span class="params">(Producer p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> toRequest;<span class="comment">//请求数</span></span><br><span class="line">    <span class="keyword">boolean</span> passToSubscriber = <span class="keyword">false</span>;<span class="comment">//是否传递给子Subscriber</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        toRequest = requested;<span class="comment">//赋值之前保存的请求数</span></span><br><span class="line">        producer = p;<span class="comment">//赋值给producer</span></span><br><span class="line">        <span class="keyword">if</span> (subscriber != <span class="keyword">null</span>) &#123;<span class="comment">//内部Subscriber不为空</span></span><br><span class="line">            <span class="keyword">if</span> (toRequest == NOT_SET) &#123;<span class="comment">//且当前的Subscriber未设置请求数</span></span><br><span class="line">                passToSubscriber = <span class="keyword">true</span>;<span class="comment">//标识传递给内部Subscriber</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (passToSubscriber) &#123;<span class="comment">//当前Subscriber未设置请求数且内部Subscriber不为空</span></span><br><span class="line">        subscriber.setProducer(producer);<span class="comment">//就把Producer也赋值给内部的Subscriber</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (toRequest == NOT_SET) &#123;</span><br><span class="line">            <span class="comment">//内部Subscriber为空且请求数未设置，就默认最大。</span></span><br><span class="line">            producer.request(Long.MAX_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//当前请求数已经设置，就给Producer。</span></span><br><span class="line">            producer.request(toRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述源码中会涉及到一个Producer到底给谁的问题。首先，如果在设置请求数时还没有初始化<code>Producer</code>，就进行累加保存。直到<code>Producer</code>被设置时，如果当前<code>Subscriber</code>未设置请求数且内部<code>Subscriber</code>不为空就把<code>Producer</code>赋值给内部的<code>Subscriber</code>，否则就会赋值给当前的<code>Subscriber</code>。要是当前<code>Subscriber</code>至今未设置请求数，就请求<code>Long.MAX_VALUE</code>数量的数据,多余部分就会忽略。</p>
<h3 id="被观察者（Observable）"><a href="#被观察者（Observable）" class="headerlink" title="被观察者（Observable）"></a>被观察者（Observable）</h3><p>说到<code>Observable</code>，有必要来认识一下其他几个接口。<br>先来看下图：<br><img src="http://static.zybuluo.com/maplejaw/iy00luh2zxa014sf7zmpxkvs/image_1alj8i1ub14ijermlrpnkflm9.png" alt="image_1alj8i1ub14ijermlrpnkflm9.png-16.9kB"></p>
<h4 id="Funtion"><a href="#Funtion" class="headerlink" title="Funtion"></a>Funtion</h4><p><code>Funtion</code>是个空接口，里面没有任何实现。FuncN相关接口则常用于类型转换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Func0 0个参数，返回R类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Func0</span>&lt;<span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Callable</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">R <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Func1 1个T类型参数，返回R类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Func1</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">call</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Func2 两种类型参数，返回R类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Func2</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">call</span><span class="params">(T1 t1, T2 t2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FuncN N种类型参数，返回R类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FuncN</span>&lt;<span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">call</span><span class="params">(Object... args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>Action接口继承于Function的空接口，ActionN相关接口源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Action0 传入0个参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action0</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Action1 传入1个参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Action2 传入2个参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action2</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(T1 t1, T2 t2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ActionN 传入N个参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActionN</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Object... args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ActionN和FuncN的区别在于ActionN没有返回值而FuncN有返回值。因此，FuncN常用来进行类型转换，ActionN用于回调数据。</p>
<h4 id="OnSubscribe"><a href="#OnSubscribe" class="headerlink" title="OnSubscribe"></a>OnSubscribe</h4><p><code>OnSubscribe</code>继承于Action1，用于提供Subscriber对象。<br><code>OnSubscribe</code>源码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action1</span>&lt;<span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h4><p>操作符函数，继承于Func1，用于变换Subscriber，R表示下游的值，T表示上游的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operator</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Func1</span>&lt;<span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">R</span>&gt;, <span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h4><p>与Operator一样，同样继承于Func1，只不过该函数用于变换Observable。T表示原先的值，R表示变换后的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transformer</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Func1</span>&lt;<span class="title">Observable</span>&lt;<span class="title">T</span>&gt;, <span class="title">Observable</span>&lt;<span class="title">R</span>&gt;&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>整个Observable中的链式操作以及线程切换大都依赖以上接口。<br>还记得开头时介绍<code>Observable.create</code>创建被观察者的那句代码吗?不难发现，只要我们触发<code>call</code>方法，Subscriber就可以开始工作了。<br><img src="http://static.zybuluo.com/maplejaw/hfcj5538jjhsxkjwref4a0yg/image_1alj9e198f3bdm1jab1m16mjvm.png" alt="image_1alj9e198f3bdm1jab1m16mjvm.png-21.9kB">。<br>此外，还可以通过<code>from</code>,<code>just</code>等等来初始化Observable，这就就不一一赘述了。</p>
<h3 id="订阅（subscribe）"><a href="#订阅（subscribe）" class="headerlink" title="订阅（subscribe）"></a>订阅（subscribe）</h3><p>在了解了观察者和被观察者后，我们就来了解下如何进行订阅。订阅相关的方法有很多。但是每一种都会最后都会被封装为<code>Subscriber</code>.<br><img src="http://static.zybuluo.com/maplejaw/9w5cccmu3klgar218zuyf7gy/image_1aqol5tvc1vp1r9vv6p1bk4ha29.png" alt="image_1aqol5tvc1vp1r9vv6p1bk4ha29.png-19.3kB"></p>
<p>Observer通过ObserverSubscriber使用代理的方式包装Observer。<br>Action通过ActionSubscriber来进行包装。<br>最终都会调用一下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.subscribe(subscriber, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Observable.subscribe中才是订阅的核心，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    <span class="comment">//省略了部分源码</span></span><br><span class="line">    </span><br><span class="line">    subscriber.onStart();<span class="comment">//这里调用onStart</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//包装成SafeSubscriber（保障onError/onComplete只会执行一次）</span></span><br><span class="line">    <span class="keyword">if</span> (!(subscriber <span class="keyword">instanceof</span> SafeSubscriber)) &#123;</span><br><span class="line">    </span><br><span class="line">        subscriber = <span class="keyword">new</span> SafeSubscriber&lt;T&gt;(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//RxJavaHooks 执行钩相关，用于拦截并修改对象</span></span><br><span class="line">        <span class="comment">//使用钩子拦截并修改onSubscribe（如果没有注册钩子的话，默认不会做修改）</span></span><br><span class="line">        RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber);</span><br><span class="line">        <span class="keyword">return</span> RxJavaHooks.onObservableReturn(subscriber);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//省略了错误处理相关的源码</span></span><br><span class="line">        subscriber.onError(RxJavaHooks.onObservableError(e));<span class="comment">//处理异常相关</span></span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed(); <span class="comment">//返回一个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当调用<code>subscribe</code>时，首先Subscriber执行onStart。并且将Subscriber包装为SafeSubscriber，用于保证onError和onComplete只执行一次，即使你写了多个onError/onComplete也不会回调多次。此外，只要执行了onError/onComplete还会进行解除订阅操作，也就是说将不能再发送数据。RxJavaHooks则是钩子相关，用于拦截修改对象，如果有需求的话可以进行注册钩子，通过RxJavaPlugins#registerXXXExecutionHook来注册相关执行钩，源码在plugins包下。<br><img src="http://static.zybuluo.com/maplejaw/jgm1yk98lgfgy0bm54ty36gk/image_1aqomk4sa1rj311pm19r61au8171am.png" alt="image_1aqomk4sa1rj311pm19r61au8171am.png-22.6kB"><br>如果没有注册钩子，默认会直接返回，不会修改任何对象。</p>
<p>从<code>RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber);</code>这句源码如果没有注册钩子的话，会直接返回<code>OnSubscribe</code>,然后调用<code>call</code>方法，Observable便开始发送数据项了。<code>RxJavaHooks.onObservableReturn</code>用于返回Subscription进行解除订阅。如果在订阅的过程中发生了异常，则会回调到<code>onError</code>中。不过需要注意的是，并不是所有的异常都会回调onError，而是会直接抛出异常。</p>
<p>以下列表中的异常如果发生是一定会被抛出的。<br><img src="http://static.zybuluo.com/maplejaw/fk9wmt93xoam12kckxdf5u9t/image_1aqon9fnt10q9k3qpa9peh15sn13.png" alt="image_1aqon9fnt10q9k3qpa9peh15sn13.png-56.6kB"></p>
<h3 id="线程切换相关（Scheduler）"><a href="#线程切换相关（Scheduler）" class="headerlink" title="线程切换相关（Scheduler）"></a>线程切换相关（Scheduler）</h3><p>RxJava中一提及线程，那么无疑就会联想到Scheduler这个叫做调度器的东西。<br>Scheduler的种类有如下几种：</p>
<table>
<thead>
<tr>
<th>调度器类型</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Schedulers.computation()</td>
<td>用于计算任务，如事件循环等，不要用于IO操作。默认线程数等于处理器的数量</td>
</tr>
<tr>
<td>Schedulers.from(executor)</td>
<td>使用指定的Executor作为调度器</td>
</tr>
<tr>
<td>Schedulers.immediate()</td>
<td>在当前线程立即开始执行任务</td>
</tr>
<tr>
<td>Schedulers.io()</td>
<td>用于IO密集型任务，如异步阻塞IO操作，线程池会根据需要增长。</td>
</tr>
<tr>
<td>Schedulers.newThread()</td>
<td>为每个任务创建一个新线程</td>
</tr>
<tr>
<td>Schedulers.trampoline()</td>
<td>在当前线程排队执行（如果队列中已经存在其他任务）</td>
</tr>
<tr>
<td>AndroidSchedulers.from(Looper)</td>
<td>切换到Looper所在的线程执行（Android）</td>
</tr>
<tr>
<td>AndroidSchedulers.mainThread()</td>
<td>切换到主线程线程执行（Android）</td>
</tr>
</tbody>
</table>
<p>Scheduler的作用不言而喻，其是一个抽象类，核心源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Worker <span class="title">createWorker</span><span class="params">()</span></span>; <span class="comment">//创建Worker</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//Worker抽象类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行一个Action，返回Subscription</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Subscription <span class="title">schedule</span><span class="params">(Action0 action)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//延时执行一个Action，返回Subscription</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">final</span> <span class="keyword">long</span> delayTime, <span class="keyword">final</span> TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">       <span class="comment">//延时周期性执行一个Action，返回Subscription，使用递归来实现周期性执行</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Subscription <span class="title">schedulePeriodically</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> periodInNanos = unit.toNanos(period);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> firstNowNanos = TimeUnit.MILLISECONDS.toNanos(now());</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> firstStartInNanos = firstNowNanos + unit.toNanos(initialDelay);</span><br><span class="line">             <span class="comment">//  MultipleAssignmentSubscription用于检查订阅状态，常用于循环内。</span></span><br><span class="line">            <span class="keyword">final</span> MultipleAssignmentSubscription mas = <span class="keyword">new</span> MultipleAssignmentSubscription();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//递归Action</span></span><br><span class="line">            <span class="keyword">final</span> Action0 recursiveAction = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line">                <span class="keyword">long</span> count;</span><br><span class="line">                <span class="keyword">long</span> lastNowNanos = firstNowNanos;</span><br><span class="line">                <span class="keyword">long</span> startInNanos = firstStartInNanos;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    action.call();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!mas.isUnsubscribed()) &#123;</span><br><span class="line">                        </span><br><span class="line">                         <span class="comment">//..</span></span><br><span class="line">                         <span class="comment">//省略了计算下一次执行时间的源码</span></span><br><span class="line">                         </span><br><span class="line">                        mas.set(schedule(<span class="keyword">this</span>, delay, TimeUnit.NANOSECONDS));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            MultipleAssignmentSubscription s = <span class="keyword">new</span> MultipleAssignmentSubscription();</span><br><span class="line">            s.set(schedule(recursiveAction, initialDelay, unit));</span><br><span class="line">            </span><br><span class="line">            mas.set(s);</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">return</span> mas;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    now() &#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>看到这里，或许你还是很好奇Worker中的线程调度吧？那我们就来看一个最简单的源码。即<code>Schedulers.newThread( )</code>的NewThreadScheduler相关源码，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThreadScheduler</span> <span class="keyword">extends</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewThreadScheduler</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NewThreadWorker(threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整体源码还是非常简洁的，NewThreadWorker继承于Worker，是核心所在。对应的抽象方法实现如下。其中<code>executor</code>为ScheduledExecutorService，因此可以用于执行延时任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> schedule(action, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (isUnsubscribed) &#123;</span><br><span class="line">           <span class="keyword">return</span> Subscriptions.unsubscribed();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> scheduleActual(action, delayTime, unit);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> ScheduledAction <span class="title">scheduleActual</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">       Action0 decoratedAction = RxJavaHooks.onScheduledAction(action); <span class="comment">//钩子</span></span><br><span class="line">       </span><br><span class="line">       ScheduledAction run = <span class="keyword">new</span> ScheduledAction(decoratedAction);</span><br><span class="line">       Future&lt;?&gt; f;</span><br><span class="line">       <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//提交到线程执行</span></span><br><span class="line">           f = executor.submit(run);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//提交到线程延时执行</span></span><br><span class="line">           f = executor.schedule(run, delayTime, unit);</span><br><span class="line">       &#125;</span><br><span class="line">       run.add(f);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> run;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>阅读完以上源码，相信对于线程的切换有了深入的了解了吧，用过Worker#schedule相关方法就可以切换到指定线程中进行执行。其他Scheduler在internal包中。这里就不一一介绍了。<br><img src="http://static.zybuluo.com/maplejaw/auy4tdz8zz1l16o69cwmyyve/image_1aqqornshvri1q8i5b81j461lfj9.png" alt="image_1aqqornshvri1q8i5b81j461lfj9.png-33.2kB"></p>
<p>下面来看看Scheduler在Rxjava中的相关应用：</p>
<h4 id="observeOn切换线程"><a href="#observeOn切换线程" class="headerlink" title="observeOn切换线程"></a>observeOn切换线程</h4><p><code>observeOn</code>方法用于指定下游Subscriber回调发生的线程，<code>observeOn</code>方法最终都会调用如下源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scheduler 线程调度器</span></span><br><span class="line"><span class="comment">//delayError 是否延迟等到全部发送完数据后才发射错误</span></span><br><span class="line"><span class="comment">//bufferSize 指定缓存大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</span><br><span class="line">         <span class="comment">//ScalarSynchronousObservable是一个用于发送单个常量值的Observable</span></span><br><span class="line">         <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> lift(<span class="keyword">new</span> OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(<span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//创建一个新的Observable并返回</span></span><br><span class="line">     <span class="keyword">return</span> create(<span class="keyword">new</span> OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>OperatorObserveOn用于转换Subscriber。<code>lift</code>用于根据Operator来转换Subscriber然后创建新的Observable。如果你传入的是ImmediateScheduler、TrampolineScheduler这种在当前线程执行的Scheduler，为了避免开销将会被直接忽略。其他线程则返回ObserveOnSubscriber。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(Subscriber&lt;? <span class="keyword">super</span> T&gt; child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> ImmediateScheduler) &#123;</span><br><span class="line">        <span class="comment">// avoid overhead, execute directly</span></span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">        <span class="comment">// avoid overhead, execute directly</span></span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//包装为ObserveOnSubscriber，转换Subscriber</span></span><br><span class="line">        ObserveOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);</span><br><span class="line">        parent.init();</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ObserveOnSubscriber继承了Action0接口，支持反压控制，可以配置是否延迟等到全部发送完数据后才发射错误通知，可以配置队列大小。ObserveOnSubscriber内部的核心方法如下：可以看出，onError/onComplete是一个赋值操作，onNext只是将数据添加到队列中，然后全部都会通过<code>schedule</code>来调取发射数据或通知。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (isUnsubscribed() || finished) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!queue.offer(on.next(t))) &#123;<span class="comment">//加入等待队列中，当生产速率大于消费速率时抛出异常，即队列满了。</span></span><br><span class="line">              onError(<span class="keyword">new</span> MissingBackpressureException());</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          schedule();<span class="comment">//调度</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (isUnsubscribed() || finished) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          finished = <span class="keyword">true</span>;</span><br><span class="line">          schedule();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> Throwable e)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (isUnsubscribed() || finished) &#123;</span><br><span class="line">              RxJavaHooks.onError(e);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          error = e;</span><br><span class="line">          finished = <span class="keyword">true</span>;</span><br><span class="line">          schedule();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (counter.getAndIncrement() == <span class="number">0</span>) &#123;<span class="comment">//利用counter来计数调用了多少次schedule（）。</span></span><br><span class="line">              <span class="comment">//recursiveScheduler为Worker</span></span><br><span class="line">              recursiveScheduler.schedule(<span class="keyword">this</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>ObserveOnSubscriber继承了Action0，因此，<code>recursiveScheduler.schedule(this);</code>中一定会调用call方法。源码如下：无非就是从队列中取出数据进行发射，如果指定了延迟发送异常通知，那么将会等到队列中的数据全部发完才会发送错误。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">long</span> missed = <span class="number">1L</span>;</span><br><span class="line">          <span class="keyword">long</span> currentEmission = emitted; <span class="comment">//当前的发射数</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> Queue&lt;Object&gt; q = <span class="keyword">this</span>.queue;</span><br><span class="line">          <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; localChild = <span class="keyword">this</span>.child;</span><br><span class="line">          <span class="keyword">final</span> NotificationLite&lt;T&gt; localOn = <span class="keyword">this</span>.on;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">long</span> requestAmount = requested.get();<span class="comment">//获取当前的请求数</span></span><br><span class="line">              </span><br><span class="line">              <span class="keyword">while</span> (requestAmount != currentEmission) &#123;</span><br><span class="line">                  <span class="keyword">boolean</span> done = finished;</span><br><span class="line">                  Object v = q.poll();<span class="comment">//从队列中取出数据，</span></span><br><span class="line">                  <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>; <span class="comment">//队列为空</span></span><br><span class="line">                  </span><br><span class="line">                  <span class="keyword">if</span> (checkTerminated(done, empty, localChild, q)) &#123;<span class="comment">//检查是否已经发送结束</span></span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  </span><br><span class="line">                  <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  </span><br><span class="line">                  localChild.onNext(localOn.getValue(v)); <span class="comment">//调用原始Subscriber发送数据</span></span><br><span class="line"></span><br><span class="line">                  currentEmission++;<span class="comment">//当前发射数+1</span></span><br><span class="line">                  <span class="keyword">if</span> (currentEmission == limit) &#123;</span><br><span class="line">                      requestAmount = BackpressureUtils.produced(requested, currentEmission);</span><br><span class="line">                      request(currentEmission);</span><br><span class="line">                      currentEmission = <span class="number">0L</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">              <span class="keyword">if</span> (requestAmount == currentEmission) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (checkTerminated(finished, q.isEmpty(), localChild, q)) &#123;</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              emitted = currentEmission;</span><br><span class="line">              missed = counter.addAndGet(-missed);</span><br><span class="line">              <span class="keyword">if</span> (missed == <span class="number">0L</span>) &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>转换完Subscriber过后,接下来将会通过lift操作符来创建下游Observable。OnSubscribeLift的核心源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">//首先调用Operator转换新Subscriber</span></span><br><span class="line">           Subscriber&lt;? <span class="keyword">super</span> T&gt; st = RxJavaHooks.onObservableLift(operator).call(o);</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//模拟订阅操作</span></span><br><span class="line">           <span class="comment">//调用新Subscriber#onStart</span></span><br><span class="line">           st.onStart();</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//parent为上游Observable#onSubscribe</span></span><br><span class="line">           parent.call(st); <span class="comment">//调用onSubscribe的call方法，开始发送数据。</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="subscribeOn切换线程"><a href="#subscribeOn切换线程" class="headerlink" title="subscribeOn切换线程"></a>subscribeOn切换线程</h4><p><code>subscribeOn</code>方法用于指定<code>subscribe()</code>所发生的线程，相关源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从源码可以看出，通过Observable#create方法又创建了一个新Observable。而OperatorSubscribeOn实现了OnSubscribe接口。用于在Scheduler中订阅观察者，核心源码自然在<code>call</code>方法中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Worker inner = scheduler.createWorker(); <span class="comment">//创建Worker</span></span><br><span class="line">      subscriber.add(inner); <span class="comment">//加入订阅列表中，方便解除订阅</span></span><br><span class="line">      <span class="comment">//调用Worker#schedule方法，切换到Worker线程中执行任务</span></span><br><span class="line">      inner.schedule(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">//获取Worker线程</span></span><br><span class="line">              <span class="keyword">final</span> Thread t = Thread.currentThread();</span><br><span class="line">              <span class="comment">//创建新Subscriber</span></span><br><span class="line">              Subscriber&lt;T&gt; s = <span class="keyword">new</span> Subscriber&lt;T&gt;(subscriber) &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">                      subscriber.onNext(t);</span><br><span class="line">                  &#125;</span><br><span class="line">                  </span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                      <span class="keyword">try</span> &#123;</span><br><span class="line">                          subscriber.onError(e);</span><br><span class="line">                      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                          inner.unsubscribe();</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  </span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                      <span class="keyword">try</span> &#123;</span><br><span class="line">                          subscriber.onCompleted();</span><br><span class="line">                      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                          inner.unsubscribe();</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  </span><br><span class="line">                  <span class="comment">//保证在Worker线程中使用Producer</span></span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducer</span><span class="params">(<span class="keyword">final</span> Producer p)</span> </span>&#123;</span><br><span class="line">                      subscriber.setProducer(<span class="keyword">new</span> Producer() &#123;</span><br><span class="line">                          <span class="meta">@Override</span></span><br><span class="line">                          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">                              <span class="keyword">if</span> (t == Thread.currentThread()) &#123;</span><br><span class="line">                                  p.request(n);</span><br><span class="line">                              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                  inner.schedule(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">                                      <span class="meta">@Override</span></span><br><span class="line">                                      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                          p.request(n);</span><br><span class="line">                                      &#125;</span><br><span class="line">                                  &#125;);</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;;</span><br><span class="line">              <span class="comment">//在Worker线程中 使用source（上游Observable）订阅（非安全）新的Subscriber。</span></span><br><span class="line">              source.unsafeSubscribe(s);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>整体流程如下，首先通过Scheduler来创建Worker，通过Worker执行Action0，Worker是一个抽象类。我们可以自己实现在子线程中工作的Worker，比如<code>NewThreadWorker</code>、<code>ThreadWorker</code>以及<code>PoolWorker</code>都是在子线程中工作的Woker。在Action0的内部new了个新的Subscriber，然后让上游的Observable订阅。由于我们的订阅是发生在Worler线程中的，因此这样子就可以达到线程切换的要求。</p>
<h3 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h3><p>Single是一种特殊的Observable。不同于Observable，它每次只能发送一个值。因此它所对应的订阅者为SingleSubscriber。SingleSubscriber与Subscriber不同的地方在于它只有两个抽象方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//发送成功时回调</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(T value)</span></span>;</span><br><span class="line"><span class="comment">//发送失败时回调</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>此外，因为每次订阅只能发送一个值，也不会产生反压问题。因此SingleSubscriber中也没有定义Producer来处理反压。</p>
<p>将Single转为Observable也很简单。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">toObservable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asObservable(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">asObservable</span><span class="params">(Single&lt;T&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传入single中已桥接好的onSubscribe即可。</span></span><br><span class="line">    <span class="keyword">return</span> Observable.create(t.onSubscribe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可能会好奇，到底是怎么实现桥接的。在Single的构造方法中做了如下桥接，以便能够实现Observable和Single之间的转换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Single</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//f为Single.OnSubscribe&lt;T&gt;</span></span><br><span class="line">    <span class="keyword">final</span> OnSubscribe&lt;T&gt; g = RxJavaHooks.onCreate(f);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//桥接OnSubscribe为Observable.OnSubscribe&lt;T&gt;</span></span><br><span class="line">    <span class="keyword">this</span>.onSubscribe = <span class="keyword">new</span> Observable.OnSubscribe&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; child)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//通过SingleDelayedProducer来控制Subscriber只能发送一个值</span></span><br><span class="line">            <span class="keyword">final</span> SingleDelayedProducer&lt;T&gt; producer = <span class="keyword">new</span> SingleDelayedProducer&lt;T&gt;(child);</span><br><span class="line">            child.setProducer(producer);</span><br><span class="line">            </span><br><span class="line">            SingleSubscriber&lt;T&gt; ss = <span class="keyword">new</span> SingleSubscriber&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">                    producer.setValue(value);<span class="comment">//如果有请求，内部会触发next()来发送数据，否则保存数据等待请求。</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">                    child.onError(error);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            child.add(ss);</span><br><span class="line">            g.call(ss);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过SingleDelayedProducer，一旦接受到值，通过<code>setValue</code>,将会触发发射数据到Subscriber中。</p>
<h3 id="Completable"><a href="#Completable" class="headerlink" title="Completable"></a>Completable</h3><p>同样是一个特殊的Observable。但Completable并不关心发送的数据，而只关心发送成功与否。</p>
<h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><p>Subject比较特殊，它既是一个Observable，也是一个Observer。</p>
<h4 id="SubjectSubscriptionManager"><a href="#SubjectSubscriptionManager" class="headerlink" title="SubjectSubscriptionManager"></a>SubjectSubscriptionManager</h4><p>Subject订阅管理器，实现了OnSubscribe接口，用来保存最近一次的值或者发射完毕的值。内部用过State来管理所有的订阅者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//当订阅者订阅前回调</span></span><br><span class="line">    Action1&lt;SubjectObserver&lt;T&gt;&gt; onStart = Actions.empty();</span><br><span class="line">    <span class="comment">//当订阅者订阅时回调（没有发射完毕）</span></span><br><span class="line">    Action1&lt;SubjectObserver&lt;T&gt;&gt; onAdded = Actions.empty();</span><br><span class="line">    <span class="comment">//当订阅者订阅时，如果已经是停止状态时回调。</span></span><br><span class="line">    Action1&lt;SubjectObserver&lt;T&gt;&gt; onTerminated = Actions.empty();</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; child)</span> </span>&#123;</span><br><span class="line">        SubjectObserver&lt;T&gt; bo = <span class="keyword">new</span> SubjectObserver&lt;T&gt;(child);</span><br><span class="line">        addUnsubscriber(child, bo);<span class="comment">//添加到订阅列表方便解除订阅。</span></span><br><span class="line">        onStart.call(bo);</span><br><span class="line">        <span class="keyword">if</span> (!child.isUnsubscribed()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (add(bo) &amp;&amp; child.isUnsubscribed()) &#123;<span class="comment">//add 添加到State</span></span><br><span class="line">                remove(bo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//add 添加到State</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(SubjectObserver&lt;T&gt; o)</span> </span>&#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            State oldState = get();</span><br><span class="line">            <span class="keyword">if</span> (oldState.terminated) &#123;<span class="comment">//如果已经停止发射，就触发onTerminated</span></span><br><span class="line">                onTerminated.call(o);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            State newState = oldState.add(o);<span class="comment">//添加到State保存</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(oldState, newState)) &#123;</span><br><span class="line">                onAdded.call(o);<span class="comment">//回调add</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h4><p>只发射来自原始Observable的最后一个值。以下例子只会接收到<code>three</code>。如果没有调用<code>onCompleted</code>,那么将不会接收到任何值，因为没法判断是否已经全部发送完毕。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer 将会只接受到 three。</span></span><br><span class="line">AsyncSubject&lt;Object&gt; subject = AsyncSubject.create();</span><br><span class="line">subject.subscribe(observer);</span><br><span class="line">subject.onNext(<span class="string">"one"</span>);</span><br><span class="line">subject.onNext(<span class="string">"two"</span>);</span><br><span class="line">subject.onNext(<span class="string">"three"</span>);</span><br><span class="line">subject.onCompleted();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>核心实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">AsyncSubject&lt;T&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SubjectSubscriptionManager&lt;T&gt; state = <span class="keyword">new</span> SubjectSubscriptionManager&lt;T&gt;();</span><br><span class="line">     <span class="comment">//创建AsyncSubject时，先配置好onTerminated，当已经停止且又有新的订阅者订阅时触发</span></span><br><span class="line">    state.onTerminated = <span class="keyword">new</span> Action1&lt;SubjectObserver&lt;T&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(SubjectObserver&lt;T&gt; o)</span> </span>&#123;</span><br><span class="line">            Object v = state.getLatest();</span><br><span class="line">            NotificationLite&lt;T&gt; nl = state.nl;</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="keyword">null</span> || nl.isCompleted(v)) &#123;</span><br><span class="line">                o.onCompleted();</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (nl.isError(v)) &#123;</span><br><span class="line">                o.onError(nl.getError(v));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                o.actual.setProducer(<span class="keyword">new</span> SingleProducer&lt;T&gt;(o.actual, nl.getValue(v)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AsyncSubject&lt;T&gt;(state, state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用onNext用于赋值</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T v)</span> </span>&#123;</span><br><span class="line">    lastValue = nl.next(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用onCompleted时，调用state.terminate设置最近值并获取订阅列表。如果是</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state.active) &#123;</span><br><span class="line">        Object last = lastValue;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = nl.completed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (SubjectObserver&lt;T&gt; bo : state.terminate(last)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last == nl.completed()) &#123;</span><br><span class="line">                bo.onCompleted();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//请求终止值</span></span><br><span class="line">                bo.actual.setProducer(<span class="keyword">new</span> SingleProducer&lt;T&gt;(bo.actual, nl.getValue(last)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h4><p>当观察者订阅BehaviorSubject时，它开始发射原始Observable最近发射的数据（在还没有收到任何数据前，我们可以指定发射一个默认值），然后继续发射其它任何来自原始Observable的数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BehaviorSubject&lt;T&gt; <span class="title">create</span><span class="params">(T defaultValue, <span class="keyword">boolean</span> hasDefault)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> SubjectSubscriptionManager&lt;T&gt; state = <span class="keyword">new</span> SubjectSubscriptionManager&lt;T&gt;();</span><br><span class="line">       <span class="keyword">if</span> (hasDefault) &#123;</span><br><span class="line">           state.setLatest(NotificationLite.instance().next(defaultValue));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//添加订阅者是触发</span></span><br><span class="line">       state.onAdded = <span class="keyword">new</span> Action1&lt;SubjectObserver&lt;T&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(SubjectObserver&lt;T&gt; o)</span> </span>&#123;</span><br><span class="line">               <span class="comment">//发送最近的一个值</span></span><br><span class="line">               o.emitFirst(state.getLatest(), state.nl);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">       &#125;;</span><br><span class="line">       state.onTerminated = state.onAdded;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> BehaviorSubject&lt;T&gt;(state, state); </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T v)</span> </span>&#123;</span><br><span class="line">       Object last = state.getLatest();</span><br><span class="line">       <span class="keyword">if</span> (last == <span class="keyword">null</span> || state.active) &#123;</span><br><span class="line">           Object n = nl.next(v);</span><br><span class="line">           <span class="keyword">for</span> (SubjectObserver&lt;T&gt; bo : state.next(n)) &#123;</span><br><span class="line">               bo.emitNext(n, state.nl);<span class="comment">//发送下一个值</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Object last = state.getLatest();</span><br><span class="line">       <span class="keyword">if</span> (last == <span class="keyword">null</span> || state.active) &#123;</span><br><span class="line">           Object n = nl.completed();</span><br><span class="line">           <span class="keyword">for</span> (SubjectObserver&lt;T&gt; bo : state.terminate(n)) &#123;</span><br><span class="line">               bo.emitNext(n, state.nl);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h4><p>PublishSubject只会把在订阅发生的时间点之后来自原始Observable的数据发射给观察者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PublishSubject&lt;Object&gt; subject = PublishSubject.create();</span><br><span class="line"><span class="comment">// observer1 将会收到所有的数据和通知</span></span><br><span class="line">subject.subscribe(observer1);</span><br><span class="line">subject.onNext(<span class="string">"one"</span>);</span><br><span class="line">subject.onNext(<span class="string">"two"</span>);</span><br><span class="line"><span class="comment">// observer2 只能收到  "three" 和 onCompleted通知</span></span><br><span class="line">subject.subscribe(observer2);</span><br><span class="line">subject.onNext(<span class="string">"three"</span>);</span><br><span class="line">subject.onCompleted();</span><br></pre></td></tr></table></figure></p>
<h4 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h4><p>ReplaySubject会发射所有来自原始Observable的数据给观察者，无论它们是何时订阅的。。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ReplaySubject&lt;Object&gt; subject = ReplaySubject.create();</span><br><span class="line"> subject.onNext(<span class="string">"one"</span>);</span><br><span class="line"> subject.onNext(<span class="string">"two"</span>);</span><br><span class="line"> subject.onNext(<span class="string">"three"</span>);</span><br><span class="line"> subject.onCompleted();</span><br><span class="line"> <span class="comment">// observer1/observer2可以收到所有的数据和通知</span></span><br><span class="line"> subject.subscribe(observer1);</span><br><span class="line"> subject.subscribe(observer2);</span><br></pre></td></tr></table></figure></p>
<p>我们可以指定一定大小或者时间，当缓存超过指定大小或者超过指定时间将会被丢弃。通过不同的<code>create</code>方法，可以创建不同类型的ReplaySubject。<br><img src="http://static.zybuluo.com/maplejaw/tiq1wtcqgs090n4mcmkr3sz7/image_1arcg8d13111k1df31ohe56d1lcp9.png" alt="image_1arcg8d13111k1df31ohe56d1lcp9.png-21.4kB"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下例子中，observer1收到two，three，four，onCompleted</span></span><br><span class="line"><span class="comment">//observer2收到three，four，onCompleted</span></span><br><span class="line">ReplaySubject&lt;String&gt; replaySubject=ReplaySubject.createWithTimeAndSize(<span class="number">100</span>, TimeUnit.MILLISECONDS,<span class="number">2</span>, Schedulers.immediate());</span><br><span class="line">    replaySubject.onNext(<span class="string">"one"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    replaySubject.onNext(<span class="string">"two"</span>);</span><br><span class="line">    replaySubject.subscribe(observer1);</span><br><span class="line">    replaySubject.onNext(<span class="string">"three"</span>);</span><br><span class="line">    replaySubject.onNext(<span class="string">"four"</span>);</span><br><span class="line">     replaySubject.onCompleted();</span><br><span class="line">    replaySubject.subscribe(observer2);</span><br></pre></td></tr></table></figure></p>
<h4 id="SerializedSubject"><a href="#SerializedSubject" class="headerlink" title="SerializedSubject"></a>SerializedSubject</h4><p>包装了Subject，内部通过SerializedObserver，使其成为线程安全的对象，以便我们可以在多个线程发送数据而不会导致顺序错乱。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>由于RxJava的内容比较多，许多细节和内容无法在文中一一赘述，比如RxJava大量运用的代理模式，线程并发处理相关等等。关于操作符的内容准备下篇单独做个系统的剖析。此外，由于本人水平问题，部分地方理解的不够透彻，如有错误之处，欢迎指出。</p>
<hr>
<p>本期解读到此结束。下一期，RxJava操作符完全解析。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/08/31/RxJava操作符完全解析/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          RxJava操作符完全解析
        
      </div>
    </a>
  
  
    <a href="/2016/07/31/OkHttp3-源码解读/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">OkHttp3 源码解读</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="RxJava-源码解读" data-title="RxJava 源码解读" data-url="http://www.maplejaw.com/2016/08/31/RxJava-源码解读/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"maplejaw"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 maplejaw
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>